<html><head><title>android-v</title><meta name="keywords" content="My Blog, Spider Bitch!"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=2" rel="stylesheet" type="text/css"><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"></head><body><h2 class="title">android-v</h2><h1 id="view"><a href="#view" class="headerlink" title="view"></a>view</h1><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><h3 id="帧动画-frame-anim"><a href="#帧动画-frame-anim" class="headerlink" title="帧动画 frame anim"></a>帧动画 frame anim</h3><p>动画类 AnimationDrawable<br>配置xml文件 animation-list<br>animation自定义 重写方法applyTransformation()改变Transformation<br>启动 setBackground()</p><h3 id="补间动画-tween-anim"><a href="#补间动画-tween-anim" class="headerlink" title="补间动画 tween anim"></a>补间动画 tween anim</h3><p>动画类 AlphaAnimation , RotateAnimation, ScaleAnimation, TranslateAnimation<br>配置xml文件 alpha, rotate, scale, translate<br>启动 AnimationUtils.loadAnimation（context，R.anim.x）;</p><h4 id="alpha"><a href="#alpha" class="headerlink" title="alpha"></a>alpha</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;&gt;  </div><div class="line">    &lt;!-- fromAlpha和toAlpha是起始透明度和结束时透明度 --&gt;  </div><div class="line">    &lt;alpha  </div><div class="line">        android:fromAlpha=&quot;1.0&quot;  </div><div class="line">        android:toAlpha=&quot;0.0&quot;  </div><div class="line">        android:startOffset=&quot;500&quot;  </div><div class="line">        android:duration=&quot;500&quot;/&gt;  </div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure><h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;&gt;  </div><div class="line">    &lt;!--  </div><div class="line">        fromDegrees:开始的角度  </div><div class="line">        toDegrees：结束的角度，+表示是正的  </div><div class="line">        当角度为负数——表示逆时针旋转  </div><div class="line">        当角度为正数——表示顺时针旋转  </div><div class="line">        pivotX：用于设置旋转时的x轴坐标  </div><div class="line">        例  </div><div class="line">           1)当值为&quot;50&quot;，表示使用绝对位置定位  </div><div class="line">           2)当值为&quot;50%&quot;，表示使用相对于控件本身定位  </div><div class="line">           3)当值为&quot;50%p&quot;，表示使用相对于控件的父控件定位  </div><div class="line">        pivotY：用于设置旋转时的y轴坐标  </div><div class="line">      --&gt;  </div><div class="line">    &lt;rotate  </div><div class="line">        android:fromDegrees=&quot;0&quot;  </div><div class="line">        android:toDegrees=&quot;+360&quot;  </div><div class="line">        android:pivotX=&quot;50%&quot;  </div><div class="line">        android:pivotY=&quot;50%&quot;  </div><div class="line">        android:duration=&quot;1000&quot;/&gt;  </div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;&gt;  </div><div class="line">   &lt;!--  </div><div class="line">       起始x轴坐标  </div><div class="line">           止x轴坐标  </div><div class="line">           始y轴坐标  </div><div class="line">           止y轴坐标  </div><div class="line">           轴的坐标  </div><div class="line">           轴的坐标  </div><div class="line">     --&gt;  </div><div class="line">   &lt;scale  </div><div class="line">       android:fromXScale=&quot;1.0&quot;  </div><div class="line">       android:toXScale=&quot;0.0&quot;  </div><div class="line">       android:fromYScale=&quot;1.0&quot;  </div><div class="line">       android:toYScale=&quot;0.0&quot;  </div><div class="line">       android:pivotX=&quot;50%&quot;  </div><div class="line">       android:pivotY=&quot;50%&quot;  </div><div class="line">       android:duration=&quot;1000&quot;/&gt;  </div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure><h4 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;&gt;  </div><div class="line">    &lt;!--  </div><div class="line">           始x轴坐标  </div><div class="line">           止x轴坐标  </div><div class="line">           始y轴坐标  </div><div class="line">           止y轴坐标  </div><div class="line">      --&gt;  </div><div class="line">    &lt;translate  </div><div class="line">        android:fromXDelta=&quot;0%&quot;  </div><div class="line">        android:toXDelta=&quot;100%&quot;  </div><div class="line">        android:fromYDelta=&quot;0%&quot;  </div><div class="line">        android:toYDelta=&quot;100%&quot;  </div><div class="line">        android:duration=&quot;2000&quot;/&gt;  </div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure><h3 id="属性动画-property-anim"><a href="#属性动画-property-anim" class="headerlink" title="属性动画 property anim"></a>属性动画 property anim</h3><p><a href="https://github.com/JakeWharton/NineOldAndroids/tree/master/sample/src/com/jakewharton/nineoldandroids/sample" target="_blank" rel="external">nineoldandroids sample</a><br>动画类 valueAnimator，objectAnimator<br>配置xml文件 alpha, rotate, scale, translate<br>启动 AnimatorInflater.loadAnimator(context, R.anim.x);</p><h4 id="valueAnimator"><a href="#valueAnimator" class="headerlink" title="valueAnimator"></a>valueAnimator</h4><p>addupdateListener() { 属性改变 }</p><h4 id="objectAnimator"><a href="#objectAnimator" class="headerlink" title="objectAnimator"></a>objectAnimator</h4><p>属性 xxx<br>setX() , getX()<br>_offx 实例化</p><h4 id="offint-offfloat-offobject-offproperty-propertyvalueHolder-setCurrentPlayTime-long-playTime"><a href="#offint-offfloat-offobject-offproperty-propertyvalueHolder-setCurrentPlayTime-long-playTime" class="headerlink" title="offint , offfloat, offobject, offproperty , propertyvalueHolder, setCurrentPlayTime(long playTime)"></a>offint , offfloat, offobject, offproperty , propertyvalueHolder, setCurrentPlayTime(long playTime)</h4><h3 id="interpolator"><a href="#interpolator" class="headerlink" title="interpolator"></a>interpolator</h3><p>差值器，控制动画的变化频率 （ ～0 —- ～1）相当于加速度 a 。<br>根据系统 SystemClock.uptimeMillis()（每次调用都获取）<br>1 计算出在(0 ~ duration ) 哪个时间点<br>2 再计算出normalizedTime （0 ～ 1）百分比<br>3 input 为 normalizedTime（0～ 1）<br>4 input 为 delta time ／ duration (0 ~ 1)<br>5 getInterpolation(float input)。<br>帧动画 补间动画 android.view.animation.Interpolator在view包下<br>属性动画 android.animation.TimeInterpolator 在animation包下<br>4.0 之后 Interpolator 继承自TimeInterpolator</p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>animation中通过applyTransformation() 来改变transformation 来作动画</p><h3 id="帧数"><a href="#帧数" class="headerlink" title="帧数"></a>帧数</h3><p>游戏一般到60 帧才流畅。 animator 睡眠时间是10ms 即100帧每秒。这个帧数可以调节静态方法ValueAnimator.setFrameDelay(long frameDelay)。</p><h3 id="TypeEvaluator"><a href="#TypeEvaluator" class="headerlink" title="TypeEvaluator"></a>TypeEvaluator</h3><p>控制做动画的view的位置。<br>根据Interpolator 计算出的fraction 和初始 、结束值来计算view 的属性值。<br>默认是 IntEvaluator 和 FloatEvaluator</p><h2 id="view-重绘的时机"><a href="#view-重绘的时机" class="headerlink" title="view 重绘的时机"></a>view 重绘的时机</h2><h3 id="主动重绘"><a href="#主动重绘" class="headerlink" title="主动重绘"></a>主动重绘</h3><p>invalidate()；<br>postinvalidate()；</p><h3 id="被动重绘"><a href="#被动重绘" class="headerlink" title="被动重绘"></a>被动重绘</h3><p>被动重绘的原则: view变化就会重绘</p><h4 id="view状态变化"><a href="#view状态变化" class="headerlink" title="view状态变化"></a>view状态变化</h4><p>focus<br>enable<br>selected<br>press<br>visiable</p><h4 id="view结构变化"><a href="#view结构变化" class="headerlink" title="view结构变化"></a>view结构变化</h4><p>增减 子view<br>宽高大小变化</p><h2 id="view绘制过程"><a href="#view绘制过程" class="headerlink" title="view绘制过程"></a>view绘制过程</h2><p>viewroot 发异步消息, 由Decorview开始</p><h3 id="1-measure-确定大小"><a href="#1-measure-确定大小" class="headerlink" title="1.measure 确定大小"></a>1.measure 确定大小</h3><p>onmeasure（）可以改变measure大小<br>setMeasureDimension（）设置大小</p><h3 id="2-layout-确定位置"><a href="#2-layout-确定位置" class="headerlink" title="2.layout 确定位置"></a>2.layout 确定位置</h3><p>onlayout（）可以改变view位置<br>setFrame（）设置（t，l，r，b）值</p><h3 id="3-draw-绘制"><a href="#3-draw-绘制" class="headerlink" title="3.draw 绘制"></a>3.draw 绘制</h3><ul><li>画背景</li><li>ondraw（）绘制视图本身</li><li>dispatchDraw（）绘制子视图</li><li>ondrawScrollBar（）绘滚动条<h3 id="invalidated调用时机"><a href="#invalidated调用时机" class="headerlink" title="invalidated调用时机"></a>invalidated调用时机</h3>重draw调用 3<h3 id="requestlayout调用时机"><a href="#requestlayout调用时机" class="headerlink" title="requestlayout调用时机"></a>requestlayout调用时机</h3>重新measure调用 1，layout调用 2</li></ul><h2 id="View-invalidate方法研究"><a href="#View-invalidate方法研究" class="headerlink" title="View invalidate方法研究"></a>View invalidate方法研究</h2><p>Invalidate 英文废弃，无效的意思。不知道写api的人为什么不用redraw之类的更直接的词语而用这个词语。<br>大家都知道，view 调用 Invalidate 方法会导致重绘。<br>那么具体的情况是什么呢？<br>我写了一个demo去研究这个方法的作用。<a href="http://download.csdn.net/detail/javalive09/6867681" target="_blank" rel="external">下载</a><br>在VISIBLE的情况下：</p><h3 id="一个非容器类的view-调用Invalidate"><a href="#一个非容器类的view-调用Invalidate" class="headerlink" title="一个非容器类的view 调用Invalidate():"></a>一个非容器类的view 调用Invalidate():</h3><p>会调用 此view的onDraw() ,重绘它自己。</p><h3 id="一个容器类的view调用Invalidate"><a href="#一个容器类的view调用Invalidate" class="headerlink" title="一个容器类的view调用Invalidate():"></a>一个容器类的view调用Invalidate():</h3><p>如果这个容器有背景，会调用 此view的onDraw() ,重绘它自己。<br>如果这个容器没有背景，不会调用 此view的onDraw() ,重绘它自己。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>不是调用Invalidate()就一定会导致重绘。</p><h2 id="addView-源码调用顺序的迷惑"><a href="#addView-源码调用顺序的迷惑" class="headerlink" title="addView 源码调用顺序的迷惑"></a>addView 源码调用顺序的迷惑</h2><p>addView 源码中方法调用顺序的迷惑<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void addView(View child,int index, LayoutParams params) &#123;  </div><div class="line">        if (DBG) &#123;  </div><div class="line">            System.out.println(this +&quot; addView&quot;);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        // addViewInner() will call child.requestLayout() when setting the new LayoutParams  </div><div class="line">        // therefore, we call requestLayout() on ourselves before, so that the child&apos;s request  </div><div class="line">        // will be blocked at our level  </div><div class="line">        requestLayout();  </div><div class="line">        invalidate(true);  </div><div class="line">        addViewInner(child, index, params, false);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure><p></p><p>为什么在addViewInner(); 前要使用requestLayout(); addViewInner里面会调用requestLayout(); 这样逻辑上是不是重复了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void requestLayout() &#123;  </div><div class="line">    mPrivateFlags |= FORCE_LAYOUT;  </div><div class="line">    mPrivateFlags |= INVALIDATED;  </div><div class="line">  </div><div class="line">    if (mLayoutParams != null) &#123;  </div><div class="line">        mLayoutParams.onResolveLayoutDirection(getResolvedLayoutDirection());  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;  </div><div class="line">        mParent.requestLayout();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>requestLayout();的很重要的一步操作是给mPrivateFlags赋上FORCE_LAYOUT值。<br>if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) 这一步逻辑是。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isLayoutRequested() &#123;  </div><div class="line">    return (mPrivateFlags &amp; FORCE_LAYOUT) == FORCE_LAYOUT;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>由于requestLayout() 是从当前view往上传递来申请重新layout布局。如果父容器的mPrivateFlags不包含FORCE_LAYOUT。执行父容器的requestLayout();<br>这里父容器mPrivateFlags包含FORCE_LAYOUT，所以不会向上传递申请重新layout布局。<br>那么 mPrivateFlags 什么时候清空FORCE_LAYOUT值呢？在view 的layout 方法最后：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;  </div><div class="line">    int oldL = mLeft;  </div><div class="line">    int oldT = mTop;  </div><div class="line">    int oldB = mBottom;  </div><div class="line">    int oldR = mRight;  </div><div class="line">    boolean changed = setFrame(l, t, r, b);  </div><div class="line">    if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;  </div><div class="line">        onLayout(changed, l, t, r, b);  </div><div class="line">        mPrivateFlags &amp;= ~LAYOUT_REQUIRED;  </div><div class="line">  </div><div class="line">        ListenerInfo li = mListenerInfo;  </div><div class="line">        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;  </div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =  </div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();  </div><div class="line">            int numListeners = listenersCopy.size();  </div><div class="line">            for (int i = 0; i &lt; numListeners; ++i) &#123;  </div><div class="line">                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    mPrivateFlags &amp;= ~FORCE_LAYOUT;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>mPrivateFlags &amp;= ~FORCE_LAYOUT 清空了FORCE_LAYOUT。也就是 这个view layout 之后 FORCE_LAYOUT会被清空。</p><p>例子代码<a href="http://download.csdn.net/detail/javalive09/6867681" target="_blank" rel="external">下载</a><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vg.addView(new Son(MainActivity.this));  </div><div class="line">vg.addView(new Son(MainActivity.this));  </div><div class="line">vg.addView(new Son(MainActivity.this));</div></pre></td></tr></table></figure><p></p><p>站在父容器vg 的角度看，会引发如下流程：</p><p>view1:</p><ol><li>requestLayout(); //发出layout消息, 触发vg 的 onMeasure(), onLayout()</li><li>invalidate(true); //发出重绘制消息，触发vg 的draw()</li><li>child.setLayoutParams(params); //会触发child的layout(), 不会向父容器方向传递触发vg的layout。<br>因为被步骤1的父容器layout 的 mPrivateFlags == FORCE_LAYOUT阻断。</li></ol><p>view2:</p><ol><li>requestLayout(); // 不会发出layout消息，不会触发vg 的 onMeasure(), onLayout()。<br>因为被步骤1的父容器layout 的 mPrivateFlags == FORCE_LAYOUT阻断。</li><li>invalidate(true); //不会发出重绘消息，不会触发vg 的draw()。<br>因为被步骤2的 mPrivateFlags DRAWN ／ DRAWING_CACHE_VALID／INVALIDATED阻断。</li><li>child.setLayoutParams(params); //会触发child的layout(), 不会向父容器方向传递触发vg的layout。<br>因为被步骤1的父容器layout 的 mPrivateFlags == FORCE_LAYOUT阻断。</li></ol><p>view3:</p><ol><li>requestLayout(); // 不会发出layout消息，不会触发vg 的 onMeasure(), onLayout()。<br>因为被步骤1的父容器layout 的 mPrivateFlags == FORCE_LAYOUT阻断。</li><li>invalidate(true); //不会发出重绘消息，不会触发vg 的draw()。<br>因为被步骤2的 mPrivateFlags DRAWN ／ DRAWING_CACHE_VALID／INVALIDATED阻断。</li><li>child.setLayoutParams(params); //会触发child的layout(), 不会向父容器方向传递触发vg的layout。<br>被步骤1的父容器layout 的 mPrivateFlags == FORCE_LAYOUT阻断。<br>所以父类容器以及子view 的 onMeasure(), onLayout() 都只会被各调用一次。</li></ol><h2 id="view-的OnTouchListener和OnClickListener的区别"><a href="#view-的OnTouchListener和OnClickListener的区别" class="headerlink" title="view 的OnTouchListener和OnClickListener的区别"></a>view 的OnTouchListener和OnClickListener的区别</h2><p>有时候会迷惑，OnTouchListener和OnClickListener究竟有什么区别。 通过源码分析一下。</p><h3 id="OnTouchListener的触发逻辑"><a href="#OnTouchListener的触发逻辑" class="headerlink" title="OnTouchListener的触发逻辑"></a>OnTouchListener的触发逻辑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;  </div><div class="line">    if (mInputEventConsistencyVerifier != null) &#123;  </div><div class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, 0);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    if (onFilterTouchEventForSecurity(event)) &#123;  </div><div class="line">        //noinspection SimplifiableIfStatement  </div><div class="line">        ListenerInfo li = mListenerInfo;  </div><div class="line">        if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED  </div><div class="line">                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;  </div><div class="line">            return true;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        if (onTouchEvent(event)) &#123;  </div><div class="line">            return true;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    if (mInputEventConsistencyVerifier != null) &#123;  </div><div class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);  </div><div class="line">    &#125;  </div><div class="line">    return false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>分发touch事件时 先判断mOnTouchListener.onTouch() 是否处理了 事件，如果方法返回true(处理了)，则不向下传递。<br>所以OnTouchListener 的触发时机是：手指一触摸就会触发。 action_down的时候就会触发。而且touchListener的字面意思”触碰监听”也比较贴切 。</p><h3 id="OnClickListener的触发逻辑"><a href="#OnClickListener的触发逻辑" class="headerlink" title="OnClickListener的触发逻辑"></a>OnClickListener的触发逻辑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public boolean onTouchEvent(MotionEvent event) &#123;  </div><div class="line">...  </div><div class="line">if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </div><div class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;  </div><div class="line">            switch (event.getAction()) &#123;  </div><div class="line">                case MotionEvent.ACTION_UP:  </div><div class="line">                    boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  </div><div class="line">                    if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123;  </div><div class="line">                        // take focus if we don&apos;t have it already and we should in  </div><div class="line">                        // touch mode.  </div><div class="line">                        boolean focusTaken = false;  </div><div class="line">                        if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;  </div><div class="line">                            focusTaken = requestFocus();  </div><div class="line">                        &#125;  </div><div class="line">  </div><div class="line">                        if (prepressed) &#123;  </div><div class="line">                            // The button is being released before we actually  </div><div class="line">                            // showed it as pressed.  Make it show the pressed  </div><div class="line">                            // state now (before scheduling the click) to ensure  </div><div class="line">                            // the user sees it.  </div><div class="line">                            setPressed(true);  </div><div class="line">                       &#125;  </div><div class="line">  </div><div class="line">                        if (!mHasPerformedLongPress) &#123;  </div><div class="line">                            // This is a tap, so remove the longpress check  </div><div class="line">                            removeLongPressCallback();  </div><div class="line">  </div><div class="line">                            // Only perform take click actions if we were in the pressed state  </div><div class="line">                            if (!focusTaken) &#123;  </div><div class="line">                                // Use a Runnable and post this rather than calling  </div><div class="line">                                // performClick directly. This lets other visual state  </div><div class="line">                                // of the view update before click actions start.  </div><div class="line">                                if (mPerformClick == null) &#123;  </div><div class="line">                                    mPerformClick = new PerformClick();  </div><div class="line">                                &#125;  </div><div class="line">                                if (!post(mPerformClick)) &#123;  </div><div class="line">                                    performClick();//触发点  </div><div class="line">                                &#125;  </div><div class="line">                            &#125;  </div><div class="line">                        &#125;  </div><div class="line">...  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面看触发点performClick()<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public boolean performClick() &#123;  </div><div class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  </div><div class="line">  </div><div class="line">    ListenerInfo li = mListenerInfo;  </div><div class="line">    if (li != null &amp;&amp; li.mOnClickListener != null) &#123;  </div><div class="line">        playSoundEffect(SoundEffectConstants.CLICK);  </div><div class="line">        li.mOnClickListener.onClick(this);//触发点击事件  </div><div class="line">        return true;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    return false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在onTouch()的事件处理的逻辑中，手指抬起 action_up 时，符合click的条件，则触发mOnClickListener的逻辑。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>OnTouchListener的触发点：action_down 手指按下时<br>OnClickListener的触发点：action_up 手指抬起时<br>OnTouchListener 处理逻辑在OnClickListener之前, 所以OnTouchListener 的onTouch（）如果返回true, 则 onTouchEvent ()中所有逻辑失效，当然OnClickListener也不会触发。</p><h2 id="View-touch的传递流程"><a href="#View-touch的传递流程" class="headerlink" title="View touch的传递流程"></a>View touch的传递流程</h2><p>1 - ViewRootImpl :deliverPointerEvent()<br>2 - PhoneWindow$DecorView :dispatchTouchEvent()<br>3 - Activity :dispatchTouchEvent()<br>4 - PhoneWindow :superDispatchTouchEvent()<br>5 - PhoneWindow$DecorView :superDispatchTouchEvent()<br>6 - ViewGroup :dispatchTouchEvent()<br>7 - ViewGroup :dispatchTransformedTouchEvent()<br>8 - ViewGroup :dispatchTouchEvent()</p><blockquote><p>a 如果该层view容器没有事件拦截 :onInterceptTouchEvent() == false</p></blockquote><p>9 - 延续第7 ～ 8步，遍历传递。<br>10 - View :dispatchTouchEvent()<br>11 - View :onTouchEvent()</p><blockquote><p>b 如果该层view容器有事件拦截 :onInterceptTouchEvent() == true</p></blockquote><p>9 - 容器view :onInterceptTouchEvent()<br>10 - ViewGroup :dispatchTransformedTouchEvent()<br>11 - View :dispatchTouchEvent()<br>12 - View :onTouchEvent()</p><h3 id="dispatchTouchEvent-调用的时机"><a href="#dispatchTouchEvent-调用的时机" class="headerlink" title="dispatchTouchEvent()调用的时机"></a>dispatchTouchEvent()调用的时机</h3><p>整个view体系保持通路的情况下，每次都调用。 只要有一层view dispatchTouchEvent返回false，短路。则之后整个view体系不会再调用此方法。</p><h3 id="onInterceptTouchEvent-调用时机"><a href="#onInterceptTouchEvent-调用时机" class="headerlink" title="onInterceptTouchEvent()调用时机"></a>onInterceptTouchEvent()调用时机</h3><p>整个view体系保持通路的情况下，action_down时，mFirstTouchTarget != null 时。返回true拦截了mFirstTouchTarget 会置空，则之后再也不会调用此方法。</p><h3 id="onTouchEvent-调用时机"><a href="#onTouchEvent-调用时机" class="headerlink" title="onTouchEvent()调用时机"></a>onTouchEvent()调用时机</h3><p>整个view体系保持通路的情况下，view类总会被调用。 在viewGroup容器类中：<br>a. 如果子View onTouch()返回false没处理（mFirstTouchTarget 没赋值==null），会调用本层的onTouch();<br>b. 本层拦截了事件（mFirstTouchTarget 没赋值==null）。会调用本层的onTouch();</p><blockquote><p>注： dispatchTouchEvent 返回false，则系统下次不会再调用此方法。没有传递成功，则系统认为此事件无需再处理了。<br>什么情况下 返回false:<br>1.有targetView(有childView在点中区域), targetView dispatchTouchEvent() / onTouchEvent() 返回 false；<br>2.无targetView(无childView在点中区域，或根本无childView), 当前view onTouchEvent() 返回 false; (是否clickable ，long_clickable)</p></blockquote><h2 id="View-draw方法传递流程"><a href="#View-draw方法传递流程" class="headerlink" title="View draw方法传递流程"></a>View draw方法传递流程</h2><p>1 - ViewRootImpl :doTraversal()<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void doTraversal() &#123;  </div><div class="line">    if (mTraversalScheduled) &#123;  </div><div class="line">        mTraversalScheduled = false;  </div><div class="line">        mHandler.getLooper().removeSyncBarrier(mTraversalBarrier);  </div><div class="line">  </div><div class="line">        if (mProfile) &#123;  </div><div class="line">            Debug.startMethodTracing(&quot;ViewAncestor&quot;);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;performTraversals&quot;);  </div><div class="line">        try &#123;  </div><div class="line">            performTraversals();  </div><div class="line">        &#125; finally &#123;  </div><div class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        if (mProfile) &#123;  </div><div class="line">            Debug.stopMethodTracing();  </div><div class="line">            mProfile = false;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>2 - ViewRootImpl :performTraversals()<br>3 - ViewRootImpl :performDraw()<br>4 - ViewRootImpl :draw()<br>5 - PhoneWindow$DecorView :draw()<br>6 - ViewGroup :dispatchDraw()<br>7 - ViewGroup :drawChild()<br>8 - View :draw()<br>9 - 延续第 5 ～ 8步 ，遍历绘制</p><h2 id="如何叠加多个listview-和gridview"><a href="#如何叠加多个listview-和gridview" class="headerlink" title="如何叠加多个listview 和gridview"></a>如何叠加多个listview 和gridview</h2><p>可以重写 listView的onMeasure方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;  </div><div class="line">     int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE ,    </div><div class="line">                MeasureSpec.AT_MOST);    </div><div class="line">     super.onMeasure(widthMeasureSpec, expandSpec);    </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p></p><p>listView类源码中的onMeasure方法 中<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (heightMode == MeasureSpec.AT_MOST) &#123;  </div><div class="line">    // TODO: after first layout we should maybe start at the first visible position, not 0  </div><div class="line">    heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>确定heightSize;<br>在measureHeightOfChildren方法中计算heightSize的逻辑。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (returnedHeight &gt;= maxHeight) &#123;  </div><div class="line">                // We went over, figure out which height to return.  If returnedHeight &gt; maxHeight,  </div><div class="line">                // then the i&apos;th position did not fit completely.  </div><div class="line">                return (disallowPartialChildPosition &gt;= 0) // Disallowing is enabled (&gt; -1)  </div><div class="line">                            &amp;&amp; (i &gt; disallowPartialChildPosition) // We&apos;ve past the min pos  </div><div class="line">                            &amp;&amp; (prevHeightWithoutPartialChild &gt; 0) // We have a prev height  </div><div class="line">                            &amp;&amp; (returnedHeight != maxHeight) // i&apos;th child did not fit completely  </div><div class="line">                        ? prevHeightWithoutPartialChild  </div><div class="line">                        : maxHeight;  </div><div class="line">            &#125;</div></pre></td></tr></table></figure><p></p><p>所以只要maxHeight 足够大就会用计算出来的listView的真实高度作为高。这里用的是Integer.MAX_VALUE</p><blockquote><p>注： gridView 的onMeasure（）逻辑也类似，所以也可以用这种方法。</p></blockquote><h2 id="如何获取listview的内容高度"><a href="#如何获取listview的内容高度" class="headerlink" title="如何获取listview的内容高度"></a>如何获取listview的内容高度</h2><p>有时候需要在listview 显示之前获取内容的高度。<br>可以用 item.measure(0,0); 方式计算大小再获取。</p><blockquote><p>注：<br>item.measure(); 高度的参数是wrap_content的情况下和measure（0，0）计算的高度是一样的。<br>所以简化一下，不去配 heightMeasureSpec的值了，直接用（0，0）参数。<br>如果要配的话，可以用 MeasureSpec.makeMeasureSpec(parentSize, MeasureSpec.AT_MOST)，但是显然这样比较麻烦。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int totalHeight = 0;  </div><div class="line">      for (int i = 0; i &lt; listAdapter.getCount(); i++) &#123;  </div><div class="line">         View listItem = listAdapter.getView(i, null, listView);  </div><div class="line">          listItem.measure(0, 0);//取wrap_content的大小的高  </div><div class="line">          totalHeight += listItem.getMeasuredHeight();  </div><div class="line">      &#125;</div></pre></td></tr></table></figure><h2 id="android-scrollview-滚动时会调用onlayout么"><a href="#android-scrollview-滚动时会调用onlayout么" class="headerlink" title="android scrollview 滚动时会调用onlayout么"></a>android scrollview 滚动时会调用onlayout么</h2><p>调用onlayout 的条件是 changed == true。 setFrame 返回 true 。也就是说，必须有， top，left，right，bottom 的值的变化。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;  </div><div class="line">    int oldL = mLeft;  </div><div class="line">    int oldT = mTop;  </div><div class="line">    int oldB = mBottom;  </div><div class="line">    int oldR = mRight;  </div><div class="line">    boolean changed = setFrame(l, t, r, b);  </div><div class="line">    if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;  </div><div class="line">        onLayout(changed, l, t, r, b);  </div><div class="line">        mPrivateFlags &amp;= ~LAYOUT_REQUIRED;  </div><div class="line">  </div><div class="line">        ListenerInfo li = mListenerInfo;  </div><div class="line">        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;  </div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =  </div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();  </div><div class="line">            int numListeners = listenersCopy.size();  </div><div class="line">            for (int i = 0; i &lt; numListeners; ++i) &#123;  </div><div class="line">                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    mPrivateFlags &amp;= ~FORCE_LAYOUT;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">protected boolean setFrame(int left, int top, int right, int bottom) &#123;</div><div class="line">    boolean changed = false;</div><div class="line"></div><div class="line">    if (DBG) &#123;</div><div class="line">        Log.d(&quot;View&quot;, this + &quot; View.setFrame(&quot; + left + &quot;,&quot; + top + &quot;,&quot;</div><div class="line">                + right + &quot;,&quot; + bottom + &quot;)&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</div><div class="line">        changed = true;</div><div class="line"></div><div class="line">        // Remember our drawn bit</div><div class="line">        int drawn = mPrivateFlags &amp; DRAWN;</div><div class="line"></div><div class="line">        int oldWidth = mRight - mLeft;</div><div class="line">        int oldHeight = mBottom - mTop;</div><div class="line">        int newWidth = right - left;</div><div class="line">        int newHeight = bottom - top;</div><div class="line">        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</div><div class="line"></div><div class="line">        // Invalidate our old position</div><div class="line">        invalidate(sizeChanged);</div><div class="line"></div><div class="line">        mLeft = left;</div><div class="line">        mTop = top;</div><div class="line">        mRight = right;</div><div class="line">        mBottom = bottom;</div><div class="line">        if (mDisplayList != null) &#123;</div><div class="line">            mDisplayList.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags |= HAS_BOUNDS;</div><div class="line"></div><div class="line"></div><div class="line">        if (sizeChanged) &#123;</div><div class="line">            if ((mPrivateFlags &amp; PIVOT_EXPLICITLY_SET) == 0) &#123;</div><div class="line">                // A change in dimension means an auto-centered pivot point changes, too</div><div class="line">                if (mTransformationInfo != null) &#123;</div><div class="line">                    mTransformationInfo.mMatrixDirty = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</div><div class="line">            // If we are visible, force the DRAWN bit to on so that</div><div class="line">            // this invalidate will go through (at least to our parent).</div><div class="line">            // This is because someone may have invalidated this view</div><div class="line">            // before this call to setFrame came in, thereby clearing</div><div class="line">            // the DRAWN bit.</div><div class="line">            mPrivateFlags |= DRAWN;</div><div class="line">            invalidate(sizeChanged);</div><div class="line">            // parent display list may need to be recreated based on a change in the bounds</div><div class="line">            // of any child</div><div class="line">            invalidateParentCaches();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Reset drawn bit to original value (invalidate turns it off)</div><div class="line">        mPrivateFlags |= drawn;</div><div class="line"></div><div class="line">        mBackgroundSizeChanged = true;</div><div class="line">    &#125;</div><div class="line">    return changed;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而scrollview 滚动时，调用的scrollTo 方法 只改变了scrollX, scrollY 的值。然后重绘，所以不会调用onlayout方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void scrollTo(int x, int y) &#123;  </div><div class="line">    if (mScrollX != x || mScrollY != y) &#123;  </div><div class="line">        int oldX = mScrollX;  </div><div class="line">        int oldY = mScrollY;  </div><div class="line">        mScrollX = x;  </div><div class="line">        mScrollY = y;  </div><div class="line">        invalidateParentCaches();  </div><div class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);  </div><div class="line">        if (!awakenScrollBars()) &#123;  </div><div class="line">            postInvalidateOnAnimation();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="View-中的-onAttachedToWindow-onDetachedFromWindow-的作用是什么？"><a href="#View-中的-onAttachedToWindow-onDetachedFromWindow-的作用是什么？" class="headerlink" title="View 中的 onAttachedToWindow onDetachedFromWindow 的作用是什么？"></a>View 中的 onAttachedToWindow onDetachedFromWindow 的作用是什么？</h2><p>这两个方法是view对自己的被add ， 被remove 的监视。<br>onAttachedToWindow 是view 本身的回调，用于初始化一些东西相当于onstart 。当view 被添加到window中，被绘制之前的回调。如addview（this view）；<br>onDetachedFromWindow 是view 本身的回调，用于销毁一些东西onstop，当view被从window中删除时的回调。如 removeview（this view）；</p><h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>onAttachedToWindow():<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">viewGroup       addview（）</div><div class="line">viewGroup       addViewInner（）</div><div class="line">view            dispatchAttachedToWindow（）</div><div class="line">onAttachedToWindow（）</div></pre></td></tr></table></figure><p></p><p>onDetachedFromWindow():<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">viewGroup     removeView（）</div><div class="line">viewGroup     removeViewInternal（）</div><div class="line">view          dispatchDetachedFromWindow（）</div><div class="line">onDetachedFromWindow（）</div></pre></td></tr></table></figure><p></p><h2 id="如何在xml中引用内部类？"><a href="#如何在xml中引用内部类？" class="headerlink" title="如何在xml中引用内部类？"></a>如何在xml中引用内部类？</h2><h3 id="ViewB继承自View"><a href="#ViewB继承自View" class="headerlink" title="ViewB继承自View"></a>ViewB继承自View</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;View    </div><div class="line">        class=&quot;com.example.ClassA$ViewB&quot;    </div><div class="line">        android:layout_width=&quot;match_parent&quot;    </div><div class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</div></pre></td></tr></table></figure><h3 id="ViewB继承自ViewGroup"><a href="#ViewB继承自ViewGroup" class="headerlink" title="ViewB继承自ViewGroup"></a>ViewB继承自ViewGroup</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;ViewGroup    </div><div class="line">    class=&quot;com.example.ClassA$ViewB&quot;    </div><div class="line">    android:layout_width=&quot;match_parent&quot;    </div><div class="line">    android:layout_height=&quot;match_parent&quot; &gt;    </div><div class="line">&lt;!-- ViewGroup内部的一些控件，比如button之类的 --&gt;    </div><div class="line">&lt;/ViewGroup&gt;</div></pre></td></tr></table></figure><h2 id="translateAnimation-setFillxxx-作用是什么？"><a href="#translateAnimation-setFillxxx-作用是什么？" class="headerlink" title="translateAnimation.setFillxxx()作用是什么？"></a>translateAnimation.setFillxxx()作用是什么？</h2><p>after,before 是用于设置动画结束之后画面停留的是哪帧。</p><h3 id="translateAnimation-setFillAfter-true"><a href="#translateAnimation-setFillAfter-true" class="headerlink" title="translateAnimation.setFillAfter(true);"></a>translateAnimation.setFillAfter(true);</h3><p>动画结束后停留在最后一帧（动画结束后画面不变）。</p><h3 id="translateAnimation-setFillBefore-true"><a href="#translateAnimation-setFillBefore-true" class="headerlink" title="translateAnimation.setFillBefore(true);"></a>translateAnimation.setFillBefore(true);</h3><p>动画结束后停留在第一帧（位置画面停留在动画开始位置）。</p><h2 id="自定义菜单时点击Menu后，自定义菜单显示，但是activity窗口没获得焦点。为什么？"><a href="#自定义菜单时点击Menu后，自定义菜单显示，但是activity窗口没获得焦点。为什么？" class="headerlink" title="自定义菜单时点击Menu后，自定义菜单显示，但是activity窗口没获得焦点。为什么？"></a>自定义菜单时点击Menu后，自定义菜单显示，但是activity窗口没获得焦点。为什么？</h2><p>自定义菜单时。一定要重写这个方法，并返回false；<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean onCreateOptionsMenu(Menu menu) &#123;  </div><div class="line">    return false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="获取View的坐标"><a href="#获取View的坐标" class="headerlink" title="获取View的坐标"></a>获取View的坐标</h2><h3 id="获取在所在父View中的坐标"><a href="#获取在所在父View中的坐标" class="headerlink" title="获取在所在父View中的坐标"></a>获取在所在父View中的坐标</h3><p>getLeft() , getTop(), getBottom(), getRight()</p><h3 id="获取在整个屏幕中的坐标"><a href="#获取在整个屏幕中的坐标" class="headerlink" title="获取在整个屏幕中的坐标"></a>获取在整个屏幕中的坐标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int[] location = new int[2];</div><div class="line">View.getLocationOnScreen(location);</div><div class="line">int x = location[0];</div><div class="line">int y = location[1];</div></pre></td></tr></table></figure><h3 id="获取在所在Activity的window中的坐标"><a href="#获取在所在Activity的window中的坐标" class="headerlink" title="获取在所在Activity的window中的坐标"></a>获取在所在Activity的window中的坐标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int[] location = new int[2];</div><div class="line">View.getLocationInWindow(location);</div><div class="line">int x = location[0];</div><div class="line">int y = location[1];</div></pre></td></tr></table></figure><h3 id="getLocalVisibleRect"><a href="#getLocalVisibleRect" class="headerlink" title="getLocalVisibleRect"></a>getLocalVisibleRect</h3><p>获取视图本身可见的坐标区域，坐标以自己的左上角为原点（0，0）</p><h3 id="getGlobalVisibleRect"><a href="#getGlobalVisibleRect" class="headerlink" title="getGlobalVisibleRect"></a>getGlobalVisibleRect</h3><p>获取视图在屏幕坐标中的可视区域</p><h2 id="canvas的画文字方法参数的意义？"><a href="#canvas的画文字方法参数的意义？" class="headerlink" title="canvas的画文字方法参数的意义？"></a>canvas的画文字方法参数的意义？</h2><p>canvas.drawText(String text, float x, float y, Paint paint)<br>y 参数的意义是文字的底部的坐标。</p><h2 id="像素的结构"><a href="#像素的结构" class="headerlink" title="像素的结构"></a>像素的结构</h2><p>颜色（一个像素用一个int表示，32位真彩色）<br><img src="http://7xoxmg.com1.z0.glb.clouddn.com/pixel.jpg" alt=""><br>alpha通道：透明度，0~255 共256级透明度<br>一张图片所占内存 = wide <em>hight </em>4 byte</p><h2 id="canvas如何画出缩放的bitmap"><a href="#canvas如何画出缩放的bitmap" class="headerlink" title="canvas如何画出缩放的bitmap"></a>canvas如何画出缩放的bitmap</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) &#123;  </div><div class="line">    if (dst == null) &#123;  </div><div class="line">        throw new NullPointerException();  </div><div class="line">    &#125;  </div><div class="line">    throwIfRecycled(bitmap);  </div><div class="line">    native_drawBitmap(mNativeCanvas, bitmap.ni(), src, dst,  </div><div class="line">                      paint != null ? paint.mNativePaint : 0,  </div><div class="line">                      mScreenDensity, bitmap.mDensity);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Rect src: 是对图片进行裁截，若是null则显示整个图片<br>Rect dst：是图片在Canvas画布中显示的区域，大于src则把src的裁截区放大，小于src则把src的裁截区缩小。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 定义矩阵对象  </div><div class="line">Matrix matrix=new Matrix(); </div><div class="line">// 缩放原图  </div><div class="line">matrix.postScale(0.5f, 0.5f); </div><div class="line">Bitmap dstbmp=Bitmap.createBitmap(bmp,0,0,bmp.getWidth(),bmp.getHeight(),matrix,true);</div></pre></td></tr></table></figure><h2 id="View自定义长按菜单实现"><a href="#View自定义长按菜单实现" class="headerlink" title="View自定义长按菜单实现"></a>View自定义长按菜单实现</h2><h3 id="触发流程"><a href="#触发流程" class="headerlink" title="触发流程"></a>触发流程</h3><p>响应view：ontouch() –&gt; performLongClick() –&gt; showContextMenu()<br>调用根容器：–&gt; getparent().showContextMenuForChild（this）会一层层将响应长按的view传递至父容器。</p><h3 id="响应逻辑"><a href="#响应逻辑" class="headerlink" title="响应逻辑"></a>响应逻辑</h3><p>在根容器中重写 showContextMenuForChild（View originalView）进行处理。</p><ol><li>originalView.onCreateContextMenu() 装填内容，originalView必须提供getContextMenuInfo()方法</li><li>showmenu()</li></ol><h2 id="计算android-view的FPS"><a href="#计算android-view的FPS" class="headerlink" title="计算android view的FPS"></a>计算android view的FPS</h2><p>FPS : frame per second 刷新率 ，每秒绘制的帧数。</p><h3 id="如何计算："><a href="#如何计算：" class="headerlink" title="如何计算："></a>如何计算：</h3><p>在onDraw() 方法中进行逻辑计算<br>每调用一次onDraw() 方法，则frame 加 1；<br>因为绘制每帧的时间不同，所以<br>当时间刚好大于1秒的时候，进行计算。<br>如绘制了60帧，刚好用了1.2秒<br>则 fps ＝ 60 / 1.2；<br>fps ＝ 50 帧/秒；</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"></div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line"></div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">//耗时的绘制</div><div class="line"></div><div class="line">draw。。。。。。。。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    // fps counter: count how many frames we draw and once a second calculate the</div><div class="line"></div><div class="line">    // frames per second</div><div class="line"></div><div class="line">    ++frames;</div><div class="line"></div><div class="line">    long nowTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">    long deltaTime = nowTime - startTime;</div><div class="line"></div><div class="line">    if (deltaTime &gt; 1000) &#123;</div><div class="line"></div><div class="line">        float secs = (float) deltaTime / 1000f;</div><div class="line"></div><div class="line">        fps = (float) frames / secs;</div><div class="line"></div><div class="line">        fpsString = &quot;fps: &quot; + fps;</div><div class="line"></div><div class="line">        startTime = nowTime;</div><div class="line"></div><div class="line">        frames = 0;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">   canvas.drawText(fpsString, getWidth() - 200, getHeight() - 80, textPaint);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="android中改变view位置的几种方法"><a href="#android中改变view位置的几种方法" class="headerlink" title="android中改变view位置的几种方法"></a>android中改变view位置的几种方法</h2><h3 id="调用-layout方法"><a href="#调用-layout方法" class="headerlink" title="调用 layout方法"></a>调用 layout方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">    int oldL = mLeft;</div><div class="line">    int oldT = mTop;</div><div class="line">    int oldB = mBottom;</div><div class="line">    int oldR = mRight;</div><div class="line">    boolean changed = setFrame(l, t, r, b);</div><div class="line">    if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;</div><div class="line">        if (ViewDebug.TRACE_HIERARCHY) &#123;</div><div class="line">            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_LAYOUT);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        onLayout(changed, l, t, r, b);</div><div class="line">        mPrivateFlags &amp;= ~LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">        if (mOnLayoutChangeListeners != null) &#123;</div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;) mOnLayoutChangeListeners.clone();</div><div class="line">            int numListeners = listenersCopy.size();</div><div class="line">            for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class="line">                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mPrivateFlags &amp;= ~FORCE_LAYOUT;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="设置MarginLayoutParams，-然后调用setLayoutParams"><a href="#设置MarginLayoutParams，-然后调用setLayoutParams" class="headerlink" title="设置MarginLayoutParams， 然后调用setLayoutParams()"></a>设置MarginLayoutParams， 然后调用setLayoutParams()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void setLayoutParams(ViewGroup.LayoutParams params) &#123;</div><div class="line">    if (params == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;Layout parameters cannot be null&quot;);</div><div class="line">    &#125;</div><div class="line">    mLayoutParams = params;</div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="外容器scrollTo-方法。改变view窗体位置。会改变所有的子View位置"><a href="#外容器scrollTo-方法。改变view窗体位置。会改变所有的子View位置" class="headerlink" title="外容器scrollTo 方法。改变view窗体位置。会改变所有的子View位置"></a>外容器scrollTo 方法。改变view窗体位置。会改变所有的子View位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void scrollTo(int x, int y) &#123;  </div><div class="line">    if (mScrollX != x || mScrollY != y) &#123;  </div><div class="line">        int oldX = mScrollX;  </div><div class="line">        int oldY = mScrollY;  </div><div class="line">        mScrollX = x;  </div><div class="line">        mScrollY = y;  </div><div class="line">        invalidateParentCaches();  </div><div class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);  </div><div class="line">        if (!awakenScrollBars()) &#123;  </div><div class="line">            invalidate(true);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="view-的scroll系列方法的理解"><a href="#view-的scroll系列方法的理解" class="headerlink" title="view 的scroll系列方法的理解"></a>view 的scroll系列方法的理解</h2><h3 id="scrollTo"><a href="#scrollTo" class="headerlink" title="scrollTo():"></a>scrollTo():</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void scrollTo(int x, int y) &#123;  </div><div class="line">    if (mScrollX != x || mScrollY != y) &#123;  </div><div class="line">        int oldX = mScrollX;  </div><div class="line">        int oldY = mScrollY;  </div><div class="line">        mScrollX = x;  </div><div class="line">        mScrollY = y;  </div><div class="line">        invalidateParentCaches();  </div><div class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);  </div><div class="line">        if (!awakenScrollBars()) &#123;  </div><div class="line">            invalidate(true);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="scrollBy"><a href="#scrollBy" class="headerlink" title="scrollBy()"></a>scrollBy()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void scrollBy(int x, int y) &#123;  </div><div class="line">    scrollTo(mScrollX + x, mScrollY + y);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="setScrollX"><a href="#setScrollX" class="headerlink" title="setScrollX"></a>setScrollX</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void setScrollX(int value) &#123;  </div><div class="line">    scrollTo(value, mScrollY);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="setScrollY"><a href="#setScrollY" class="headerlink" title="setScrollY"></a>setScrollY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void setScrollY(int value) &#123;  </div><div class="line">    scrollTo(mScrollX, value);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>scroll方法针对的是view中的内容。<br>如view.scrollTo(50,0); 表示的是针对内容的（0，0）坐标view滚动了50个像素。<br>展现的是，内容向左边移动了50个像素。<br><img src="http://7xoxmg.com1.z0.glb.clouddn.com/scroll.jpg" alt=""></p><h2 id="LayoutInflater-的inflate-int-resource-ViewGroup-root-boolean-attachToRoot-方法研究"><a href="#LayoutInflater-的inflate-int-resource-ViewGroup-root-boolean-attachToRoot-方法研究" class="headerlink" title="LayoutInflater 的inflate(int resource, ViewGroup root, boolean attachToRoot)方法研究"></a>LayoutInflater 的inflate(int resource, ViewGroup root, boolean attachToRoot)方法研究</h2><h3 id="情况一：-root-null-attachToRoot-false"><a href="#情况一：-root-null-attachToRoot-false" class="headerlink" title="情况一： root =null,  attachToRoot = false;"></a>情况一： root =null, attachToRoot = false;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">View temp = createViewFromTag(root, name, attrs);  </div><div class="line">  </div><div class="line">// Inflate all children under temp  </div><div class="line">rInflate(parser, temp, attrs, true);  </div><div class="line">  </div><div class="line">return temp;</div></pre></td></tr></table></figure><h3 id="情况二：root-null-attachToRoot-false"><a href="#情况二：root-null-attachToRoot-false" class="headerlink" title="情况二：root != null, attachToRoot = false;"></a>情况二：root != null, attachToRoot = false;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">View temp = createViewFromTag(root, name, attrs);  </div><div class="line">  </div><div class="line">ViewGroup.LayoutParams params = root.generateLayoutParams(attrs);  </div><div class="line">temp.setLayoutParams(params);  </div><div class="line">  </div><div class="line">// Inflate all children under temp  </div><div class="line">rInflate(parser, temp, attrs, true);  </div><div class="line">  </div><div class="line">return temp;</div></pre></td></tr></table></figure><h3 id="情况三：root-null-attachToRoot-true"><a href="#情况三：root-null-attachToRoot-true" class="headerlink" title="情况三：root != null, attachToRoot = true;"></a>情况三：root != null, attachToRoot = true;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">View temp = createViewFromTag(root, name, attrs);  </div><div class="line">  </div><div class="line">ViewGroup.LayoutParams params = root.generateLayoutParams(attrs);  </div><div class="line">temp.setLayoutParams(params);  </div><div class="line">  </div><div class="line">// Inflate all children under temp  </div><div class="line">rInflate(parser, temp, attrs, true);  </div><div class="line">  </div><div class="line">root.addView(temp, params);  </div><div class="line">  </div><div class="line">return root;</div></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="root为空时"><a href="#root为空时" class="headerlink" title="root为空时"></a>root为空时</h4><p>返回temp。</p><h4 id="root-不为空时"><a href="#root-不为空时" class="headerlink" title="root 不为空时"></a>root 不为空时</h4><p>attachToRoot = true 。返回root；<br>attachToRoot = false。设置temp layoutParams 。返回temp。</p><h2 id="ViewPager-SimpleOnPageChangeListener中回调函数的调用场景"><a href="#ViewPager-SimpleOnPageChangeListener中回调函数的调用场景" class="headerlink" title="ViewPager SimpleOnPageChangeListener中回调函数的调用场景"></a>ViewPager SimpleOnPageChangeListener中回调函数的调用场景</h2><p>Listener 的源码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">240     public static class SimpleOnPageChangeListener implements OnPageChangeListener &#123;  </div><div class="line">241         @Override  </div><div class="line">242         public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;  </div><div class="line">243             // This space for rent  </div><div class="line">244         &#125;  </div><div class="line">245   </div><div class="line">246         @Override  </div><div class="line">247         public void onPageSelected(int position) &#123;  </div><div class="line">248             // This space for rent  </div><div class="line">249         &#125;  </div><div class="line">250   </div><div class="line">251         @Override  </div><div class="line">252         public void onPageScrollStateChanged(int state) &#123;  </div><div class="line">253             // This space for rent  </div><div class="line">254         &#125;  </div><div class="line">255     &#125;</div></pre></td></tr></table></figure><p></p><h3 id="1-onPageScrolled-int-position-float-positionOffset-int-positionOffsetPixels-："><a href="#1-onPageScrolled-int-position-float-positionOffset-int-positionOffsetPixels-：" class="headerlink" title="1.onPageScrolled(int position, float positionOffset, int positionOffsetPixels)："></a>1.onPageScrolled(int position, float positionOffset, int positionOffsetPixels)：</h3><p>position:当前的位置<br>positionoffset:当前滚动比例（左－右／0-1）（右－左／1-0）<br>positionOffsetPixels：当前实际滚动的像素（左－右／0-页宽） （右－左／页宽－0）</p><h4 id="被调用的场景"><a href="#被调用的场景" class="headerlink" title="被调用的场景:"></a>被调用的场景:</h4><p>ViewPager滚动时总被回调，这个函数在操作ViewPager时被回调很多次。<br>1.手指拖动 action_move 。n次<br>2.惯性还原 computeScroll()。n次</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>做view的动画效果时可以用这个回调函数。</p><h3 id="2-onPageSelected-int-position"><a href="#2-onPageSelected-int-position" class="headerlink" title="2.onPageSelected(int position)"></a>2.onPageSelected(int position)</h3><h4 id="被调用的场景："><a href="#被调用的场景：" class="headerlink" title="被调用的场景："></a>被调用的场景：</h4><p>ViewPager确定页面是哪一页时。1次</p><ol><li>手指拖动后抬起 action_up 。1次</li><li>或者手指滑动超出屏幕时 action_cancel。1次<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4>页面切换后改变对应的tab的状态可以用这个回调函数。<h3 id="3-onPageScrollStateChanged-int-state"><a href="#3-onPageScrollStateChanged-int-state" class="headerlink" title="3.onPageScrollStateChanged(int state):"></a>3.onPageScrollStateChanged(int state):</h3><h4 id="被调用的场景：-1"><a href="#被调用的场景：-1" class="headerlink" title="被调用的场景："></a>被调用的场景：</h4>ViewPager状态切换时被调用。这个函数在操作ViewPager时被回调3次。<br>1.开始滚动 dragging拖动状态。1次<br>2.惯性滚动 settling还原状态。1次<br>3.滚动结束 idle空闲状态。1次<h4 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h4>做页面状态变化后引起的view特效时可以用这个回调函数</li></ol><h2 id="TextView-setEms-方法名字"><a href="#TextView-setEms-方法名字" class="headerlink" title="TextView setEms 方法名字"></a>TextView setEms 方法名字</h2><p>Android TextView setEms() 作用是设置textview的字符宽度。但是名字很奇怪。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * Makes the TextView exactly this many ems wide </div><div class="line"> * </div><div class="line"> * @attr ref android.R.styleable#TextView_ems </div><div class="line"> */  </div><div class="line">@android.view.RemotableViewMethod  </div><div class="line">public void setEms(int ems) &#123;  </div><div class="line">    mMaxWidth = mMinWidth = ems;  </div><div class="line">    mMaxWidthMode = mMinWidthMode = EMS;  </div><div class="line">  </div><div class="line">    requestLayout();  </div><div class="line">    invalidate();  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>An em is a unit in the field of typography<br>em是一个印刷排版的单位，表示字宽的单位。 em字面意思为：equal M （和M字符一致的宽度为一个单位）简称em。<br>ems是em的复数表达。<br><a href="http://en.wikipedia.org/wiki/Em_%28typography%29" target="_blank" rel="external">em 的具体来历？</a></p><h2 id="View容器-measure-流程"><a href="#View容器-measure-流程" class="headerlink" title="View容器 measure 流程"></a>View容器 measure 流程</h2><h3 id="FrameLayout-onMeasure"><a href="#FrameLayout-onMeasure" class="headerlink" title="FrameLayout onMeasure()"></a>FrameLayout onMeasure()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.    measureChildWithMargins() ViewGroup.Java</div><div class="line">1.1   getChildMeasureSpec()     ViewGroup.java</div><div class="line">1.2   child.measure()  View.java</div><div class="line">1.2.1 chlid.onMeasure()        </div><div class="line"></div><div class="line">2.    resolveSizeAndState()     View.java</div><div class="line">3.    setMeasuredDimension()    View.java</div></pre></td></tr></table></figure><h3 id="LinearLayout-onMeasure"><a href="#LinearLayout-onMeasure" class="headerlink" title="LinearLayout onMeasure()"></a>LinearLayout onMeasure()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.    measureChildWithMargins() ViewGroup.java</div><div class="line">1.1   getChildMeasureSpec()     ViewGroup.java</div><div class="line">1.2   child.measure()  View.java</div><div class="line">1.2.1 chlid.onMeasure()        </div><div class="line"></div><div class="line">2.    resolveSizeAndState()     View.java</div><div class="line">3.    setMeasuredDimension()    View.java</div></pre></td></tr></table></figure><h3 id="RelateveLayout-onMeasure"><a href="#RelateveLayout-onMeasure" class="headerlink" title="RelateveLayout onMeasure()"></a>RelateveLayout onMeasure()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.    measureChild()            RelateveLayout.java</div><div class="line">1.1   getChildMeasureSpec()     RelateveLayout.java</div><div class="line">1.2   child.measure()  View.java</div><div class="line">1.2.1 chlid.onMeasure()        </div><div class="line"></div><div class="line">2.    resolveSizeAndState()    View.java</div><div class="line">3.    setMeasuredDimension()    View.java</div></pre></td></tr></table></figure><h3 id="AbsoluteLayout-onMeasure"><a href="#AbsoluteLayout-onMeasure" class="headerlink" title="AbsoluteLayout onMeasure()"></a>AbsoluteLayout onMeasure()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.    measureChildren()         ViewGroup.java</div><div class="line">1.1   getChildMeasureSpec()     ViewGroup.java</div><div class="line">1.2   child.measure()  View.java</div><div class="line">1.2.1 chlid.onMeasure()        </div><div class="line"></div><div class="line">2.    resolveSizeAndState()    View.java</div><div class="line">3.    setMeasuredDimension()    View.java</div></pre></td></tr></table></figure><hr><h1 id="window"><a href="#window" class="headerlink" title="window"></a>window</h1><h2 id="animation-1"><a href="#animation-1" class="headerlink" title="animation"></a>animation</h2><h3 id="启动动画"><a href="#启动动画" class="headerlink" title="启动动画"></a>启动动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">startActivity(new Intent(A.this, B.class));  </div><div class="line">overridePendingTransition(inAnim, outAnim);</div></pre></td></tr></table></figure><h3 id="结束动画"><a href="#结束动画" class="headerlink" title="结束动画"></a>结束动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">finish();  </div><div class="line">activity.overridePendingTransition(inAnim, outAnim);</div></pre></td></tr></table></figure><h3 id="全局activity动画"><a href="#全局activity动画" class="headerlink" title="全局activity动画"></a>全局activity动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;Theme.Test&quot; parent=&quot;@android:style/Theme.Light.NoTitleBar&quot;&gt;  </div><div class="line">    &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/Animation.Activity.Test&lt;/item&gt;  </div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;Animation.Activity.Test&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt;  </div><div class="line">    &lt;item name=&quot;android:activityOpenEnterAnimation&quot;&gt;@anim/activity_open_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:activityOpenExitAnimation&quot;&gt;@anim/activity_open_exit&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:activityCloseEnterAnimation&quot;&gt;@anim/activity_close_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:activityCloseExitAnimation&quot;&gt;@anim/activity_close_exit&lt;/item&gt;  </div><div class="line">             </div><div class="line">    &lt;item name=&quot;android:taskOpenEnterAnimation&quot;&gt;@anim/activity_open_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskOpenExitAnimation&quot;&gt;@anim/activity_open_exit&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskCloseEnterAnimation&quot;&gt;@anim/activity_close_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskCloseExitAnimation&quot;&gt;@anim/activity_close_exit&lt;/item&gt;  </div><div class="line">             </div><div class="line">    &lt;item name=&quot;android:taskToFrontEnterAnimation&quot;&gt;@anim/activity_open_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskToFrontExitAnimation&quot;&gt;@anim/activity_open_exit&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskToBackEnterAnimation&quot;&gt;@anim/activity_close_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskToBackExitAnimation&quot;&gt;@anim/activity_close_exit&lt;/item&gt;  </div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure><h2 id="不影响系统交互的悬浮窗window参数设置"><a href="#不影响系统交互的悬浮窗window参数设置" class="headerlink" title="不影响系统交互的悬浮窗window参数设置"></a>不影响系统交互的悬浮窗window参数设置</h2><p>type:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WindowManager.LayoutParams.TYPE_TOAST</div></pre></td></tr></table></figure><p></p><p>flag：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|</div><div class="line">        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if (mVolumeView == null) &#123;  </div><div class="line">    WindowManager mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);  </div><div class="line">    View rootView = View.inflate(context, R.layout.volume_layout, null);  </div><div class="line">    mVolumeView = (VolumeView) rootView.findViewById(R.id.volume);  </div><div class="line">    WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(  </div><div class="line">            WindowManager.LayoutParams.MATCH_PARENT,  </div><div class="line">            WindowManager.LayoutParams.MATCH_PARENT,  </div><div class="line">            WindowManager.LayoutParams.TYPE_TOAST,  </div><div class="line">            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|  </div><div class="line">                    WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,  </div><div class="line">            PixelFormat.TRANSLUCENT);  </div><div class="line">    layoutParams.gravity = Gravity.TOP;  </div><div class="line">    mWindowManager.addView(rootView, layoutParams);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="如何监听window的back键"><a href="#如何监听window的back键" class="headerlink" title="如何监听window的back键"></a>如何监听window的back键</h2><p>可以重写window的根view的dispatchKeyEvent方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">WindowManager mWindowManager = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);  </div><div class="line">Display display = mWindowManager.getDefaultDisplay();  </div><div class="line">int width = display.getWidth();  </div><div class="line">int height = display.getHeight();  </div><div class="line">int statusBarHeight = getStatusBarHeight();  </div><div class="line">final PopupWindow pw = new PopupWindow(width, height - statusBarHeight);  </div><div class="line">  </div><div class="line">final FrameLayout container = new FrameLayout(getContext())&#123;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public boolean dispatchKeyEvent(KeyEvent event) &#123;  </div><div class="line">        if(event.getAction() == KeyEvent.ACTION_UP) &#123;  </div><div class="line">            if(event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123;  </div><div class="line">                Log.addLog(this, &quot;window height =&quot; + pw.getHeight());  </div><div class="line">                removeAllViews();  </div><div class="line">                pw.dismiss();  </div><div class="line">                return true;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return super.dispatchKeyEvent(event);  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;;  </div><div class="line">container.addView(view, params);  </div><div class="line">pw.setContentView(container);  </div><div class="line">pw.setFocusable(true);  </div><div class="line">pw.setAnimationStyle(R.style.popUpWindowAnimation);  </div><div class="line">pw.showAtLocation(this, Gravity.NO_GRAVITY, 0, statusBarHeight);</div></pre></td></tr></table></figure><p></p><hr><h1 id="设备的适配"><a href="#设备的适配" class="headerlink" title="设备的适配"></a>设备的适配</h1><p><img src="http://7xoxmg.com1.z0.glb.clouddn.com/fitres.jpg" alt=""></p><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="undefined";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div></body></html>