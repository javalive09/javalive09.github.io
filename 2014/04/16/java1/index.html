<!doctype html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="基本类型数据类型基本数据类型（4类8种，能自动装箱）整形byte（8 bit，1个字节 -128~127）存储和传输容量的计量单位，字节。最早的PC机数据总线宽度是8（8根线）用8位表示一个字（c中char是一个字节）表示方法1：byte b = 1;注意：默认类型是int型，所以当b在[-128,127]之间时编译器不会报错。例如：byte a = 1；byte b = 2；byte c；c ="><meta property="og:type" content="article"><meta property="og:title" content="Java1"><meta property="og:url" content="http://yoursite.com/2014/04/16/Java1/index.html"><meta property="og:site_name" content="200code"><meta property="og:description" content="基本类型数据类型基本数据类型（4类8种，能自动装箱）整形byte（8 bit，1个字节 -128~127）存储和传输容量的计量单位，字节。最早的PC机数据总线宽度是8（8根线）用8位表示一个字（c中char是一个字节）表示方法1：byte b = 1;注意：默认类型是int型，所以当b在[-128,127]之间时编译器不会报错。例如：byte a = 1；byte b = 2；byte c；c ="><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/array.jpg"><meta property="og:updated_time" content="2018-09-22T05:27:13.729Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java1"><meta name="twitter:description" content="基本类型数据类型基本数据类型（4类8种，能自动装箱）整形byte（8 bit，1个字节 -128~127）存储和传输容量的计量单位，字节。最早的PC机数据总线宽度是8（8根线）用8位表示一个字（c中char是一个字节）表示方法1：byte b = 1;注意：默认类型是int型，所以当b在[-128,127]之间时编译器不会报错。例如：byte a = 1；byte b = 2；byte c；c ="><meta name="twitter:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/array.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"always"},fancybox:!1,motion:!1,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2014/04/16/Java1/"><title>Java1 | 200code</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?afd325d3333e718fc607b569c45d57a4";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">200code</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="https://200code.com/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/04/16/Java1/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="peter"><meta itemprop="description" content=""><meta itemprop="image" content="http://7xoxmg.com1.z0.glb.clouddn.com/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="200code"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="200code" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java1</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-04-16T10:13:36+08:00">2014-04-16</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型（4类8种，能自动装箱）"><a href="#基本数据类型（4类8种，能自动装箱）" class="headerlink" title="基本数据类型（4类8种，能自动装箱）"></a>基本数据类型（4类8种，能自动装箱）</h3><h4 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h4><h5 id="byte（8-bit，1个字节-128-127）"><a href="#byte（8-bit，1个字节-128-127）" class="headerlink" title="byte（8 bit，1个字节 -128~127）"></a>byte（8 bit，1个字节 -128~127）</h5><p>存储和传输容量的计量单位，字节。最早的PC机数据总线宽度是8（8根线）用8位表示一个字（c中char是一个字节）<br>表示方法1：byte b = 1;<br>注意：默认类型是int型，所以当b在[-128,127]之间时编译器不会报错。<br>例如：byte a = 1；byte b = 2；byte c；<br>c = a + 1; //会报错，相当于把int赋值给byte<br>c = a + b //会报错，相当于把int赋值给byte<br>short （16 bit， 2个字节）<br>short a = 1;<br>int b = a;//编译报错<br>注意：不可以显示的将范围大的数据类型赋值给范围小的数据类型<br>总结：可以将范围小的值赋给表示范围大的变量；但不能将表示范围大的值赋给表示范围小的变量，只能通过强制类型转换<br>范围大的强转成范围小的变量时：前面舍位<br>范围小的强转成范围大的变量时：前面补位 ,如是正数前面补位0，如是负数前面补位1.</p><h5 id="short（16-bit，-2个字节）"><a href="#short（16-bit，-2个字节）" class="headerlink" title="short（16 bit， 2个字节）"></a>short（16 bit， 2个字节）</h5><p>short a = 1;<br>int b = a;//编译报错<br>注意：不可以显示的将范围大的数据类型赋值给范围小的数据类型<br>总结：可以将范围小的值赋给表示范围大的变量；但不能将表示范围大的值赋给表示范围小的变量，只能通过强制类型转换<br>范围大的强转成范围小的变量时：前面舍位<br>范围小的强转成范围大的变量时：前面补位 ,如是正数前面补位0，如是负数前面补位1.</p><h5 id="int（32-bit，4个字节）"><a href="#int（32-bit，4个字节）" class="headerlink" title="int（32 bit，4个字节）"></a>int（32 bit，4个字节）</h5><p>整形的默认类型<br>表示方法: int i = 1;</p><h5 id="long（64-bit，8个字节）"><a href="#long（64-bit，8个字节）" class="headerlink" title="long（64 bit，8个字节）"></a>long（64 bit，8个字节）</h5><p>表示方法1： long m = 1;<br>表示方法2： long m = 2l;<br>表示方法3： long m = 2L;</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><h5 id="float（32bit，-4个字节）"><a href="#float（32bit，-4个字节）" class="headerlink" title="float（32bit， 4个字节）"></a>float（32bit， 4个字节）</h5><p>表示方法1：float f = 11.11f;<br>表示方法2：float f = 11.11F;</p><h5 id="double（64bit，8个字节-）"><a href="#double（64bit，8个字节-）" class="headerlink" title="double（64bit，8个字节 ）"></a>double（64bit，8个字节 ）</h5><p>浮点型的默认类型<br>表示方法1：double d = 11.11;<br>表示方法2：double d = 11.11D;<br>表示方法3：double d = 11.11d;</p><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><h5 id="char（16-bit，-2个字节）"><a href="#char（16-bit，-2个字节）" class="headerlink" title="char（16 bit， 2个字节）"></a>char（16 bit， 2个字节）</h5><p>表示方法1：char c = ‘c’;表示一个字符<br>表示方法2：char c = 56;表示一个整数</p><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><h5 id="boolean（1-bit）"><a href="#boolean（1-bit）" class="headerlink" title="boolean（1 bit）"></a>boolean（1 bit）</h5><p>为了纪念英国数学家Boole-George，在逻辑运算（与或非，因果关系的运算）中有突出贡献<br>表示方法： boolean b =true/false;</p><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><h5 id="正数"><a href="#正数" class="headerlink" title="正数"></a>正数</h5><p>小范围 –&gt; 大范围 ： 前面空位补0<br>大范围 –&gt; 小范围 ： 前面空位去0</p><h5 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h5><p>小范围 –&gt; 大范围 ： 前面空位补1<br>大范围 –&gt; 小范围 ： 前面空位去1</p><h4 id="十六进制字符串转换成int方法"><a href="#十六进制字符串转换成int方法" class="headerlink" title="十六进制字符串转换成int方法"></a>十六进制字符串转换成int方法</h4><p>有时候编写color 相关 的程序时，需要将十六进制字符串转换成int。<br>String str = “0xC0A80010”;<br>Integer ss = 0xC0A80010;<br>Long longStr = Long.parseLong(str.substring(2), 16);<br>ss = longStr.intValue();<br>System.out.println(ss);<br>System.out.println(Integer.toHexString(ss));<br>打印结果：<br>-1062731760<br>c0a80010</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><h4 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h4><h5 id="包装类（能自动拆箱）"><a href="#包装类（能自动拆箱）" class="headerlink" title="包装类（能自动拆箱）"></a>包装类（能自动拆箱）</h5><p>Byte，Short，<br>Integer（自动装箱时 ，integer有一个缓存，介于-128~127之间的整数装箱时会用缓存的内容，超过范围会生成新的对象，所以比较integer时要注意 integer == integer）<br>Long，Float，Double，Character，Boolean</p><h5 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h5><p>枚举每个元素都是该类的实例<br>枚举元素必须位于枚举类最开始<br>枚举只有一个成员时，可以作为一种单例实现形式</p><h5 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h5><h4 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h4><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><p>String的本质是char数组<br>private final char value[];<br>默认数组长度是0</p><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p>线程不安全<br>本质是char数组<br>char[]value<br>默认数组长度是16<br>增长时int newCapacity =value.length * 2 + 2;</p><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>线程安全<br>char[]value<br>默认数组长度是16<br>增长时int newCapacity = value.length * 2 + 2;</p><h4 id="String占用字节数"><a href="#String占用字节数" class="headerlink" title="String占用字节数"></a>String占用字节数</h4><p>Char c = “我”;//占用2个byte字节<br>String str = “我”；<br>byte [] bytes = str.getByte();<br>byte长度是3而不是2<br>因为str.getBytes（encoding）是获取指定编码的byte数组，通常GBK是2个字节，utf-8是3个字节。如果不指定，则去默认的encoding。</p><h4 id="关于分隔"><a href="#关于分隔" class="headerlink" title="关于分隔"></a>关于分隔</h4><p>StringTokenizer（字符串分隔解析器，默认分隔符：空格、回车、Tab）<br>Token被分隔字符串中的一块，两端有分隔符</p><h4 id="对象个数"><a href="#对象个数" class="headerlink" title="对象个数"></a>对象个数</h4><p>String在方法区中有一个字符串池（常量）。每次都会在池中搜寻一次。<br>Stringa = “abc”; 如果池中有，则直接用池中的，如果没有在池中新建一个<br>所以String a = new String（“abc”）；会建立两个对象。</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="int-和-Integer-有什么区别？"><a href="#int-和-Integer-有什么区别？" class="headerlink" title="int 和 Integer 有什么区别？"></a>int 和 Integer 有什么区别？</h4><p>Int是Java的原始数据类型，Integer是java为int提供的封装类。</p><h4 id="short-s1-1-s1-s1-1-有什么错"><a href="#short-s1-1-s1-s1-1-有什么错" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有什么错?"></a>short s1 = 1; s1 = s1 + 1;有什么错?</h4><p>s1+1运算结果是int型，需要强制转换类型。</p><h4 id="char型变量中能不能存贮一个中文汉字"><a href="#char型变量中能不能存贮一个中文汉字" class="headerlink" title="char型变量中能不能存贮一个中文汉字?"></a>char型变量中能不能存贮一个中文汉字?</h4><p>在C语言中，char类型占1一个字节，而汉子占2个字节，所以不能存储。<br>在Java中，char类型占2个字节，而且Java默认采用Unicode编码，以个Unicode码是16位，所以一个Unicode码占两个字节，Java中无论汉字还是英文字母都是用Unicode编码来表示的。所以，在Java中，char类型变量可以存储一个中文汉字。</p><h4 id="Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="Java支持的数据类型有哪些？什么是自动拆装箱？"></a>Java支持的数据类型有哪些？什么是自动拆装箱？</h4><p>Java语言支持的8中基本数据类型是：byte short int long float double boolean char<br>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。</p><h2 id="编码知识"><a href="#编码知识" class="headerlink" title="编码知识"></a>编码知识</h2><h3 id="Bit（binary-digit二进制数，比特）"><a href="#Bit（binary-digit二进制数，比特）" class="headerlink" title="Bit（binary  digit二进制数，比特）"></a>Bit（binary digit二进制数，比特）</h3><p>电脑数据量的最小单位，二进制系统中每个1或0就是一个位（bit）<br>1 Byte = 8 bit<br>1 KB = 1024 Byte<br>1 MB = 1024 KB<br>1 GB = 1024 MB<br>1 TB = 1024 GB （10TB大约等于一个人脑的存储量）</p><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>原始 7位二进制表示字符<br>现代 8位二进制表示字符<br>中文 2个byte字节表示<br>标准ASCII表：<a href="http://baike.baidu.com/view/15482.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/15482.htm</a></p><h3 id="ISO8859-1-（8位二进制，1个byte字节表示字符）"><a href="#ISO8859-1-（8位二进制，1个byte字节表示字符）" class="headerlink" title="ISO8859-1 （8位二进制，1个byte字节表示字符）"></a>ISO8859-1 （8位二进制，1个byte字节表示字符）</h3><p>加入αβγ（西方文字）</p><h3 id="Unicode（16位二进制，2个byte字节表示字符，又叫万国码）java编码格式"><a href="#Unicode（16位二进制，2个byte字节表示字符，又叫万国码）java编码格式" class="headerlink" title="Unicode（16位二进制，2个byte字节表示字符，又叫万国码）java编码格式"></a>Unicode（16位二进制，2个byte字节表示字符，又叫万国码）java编码格式</h3><p>中文 3个byte字节表示<br>αβ 2个byte字节表示<br>英文，数字 1个字节表示</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>中文 2个byte字节表示<br>其他 1个byte字节表示</p><h3 id="base64-编码"><a href="#base64-编码" class="headerlink" title="base64 编码"></a>base64 编码</h3><p>由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。<br>Base64中是一种基于64个可打印字符来表示二进制数据的表示方法。Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。<br>注：在android中遇到解码时调用 ：Base64.decode(input, NO_WRAP) 总崩溃，出现IllegalArgumentException: bad base-64 异常。这是传参错误引起的。</p><h3 id="关于字母"><a href="#关于字母" class="headerlink" title="关于字母"></a>关于字母</h3><p>大写字母和小写字符之间数值上差32<br>a 是 97；A是65<br>获取content-length 字符串的长度：<br>length = result.getBytes(“utf-8”).length();</p><h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>以下划线、字母、$开头都可以。唯独不能用数字开头。<br>首字母小写，单词间驼峰标示<br>常量全部大写，单词间用“_”连接</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="静态变量（内存低地址区域，静态区）"><a href="#静态变量（内存低地址区域，静态区）" class="headerlink" title="静态变量（内存低地址区域，静态区）"></a>静态变量（内存低地址区域，静态区）</h4><p>Static关键字的变量</p><h4 id="成员变量（存放在Heap堆中）"><a href="#成员变量（存放在Heap堆中）" class="headerlink" title="成员变量（存放在Heap堆中）"></a>成员变量（存放在Heap堆中）</h4><p>new中存放的变量</p><h4 id="局部变量（local-variables内存高地址区域，存放在Stack栈中）"><a href="#局部变量（local-variables内存高地址区域，存放在Stack栈中）" class="headerlink" title="局部变量（local variables内存高地址区域，存放在Stack栈中）"></a>局部变量（local variables内存高地址区域，存放在Stack栈中）</h4><p>方法中的变量<br>包括基本变量、对象地址<br>方法参数属于局部变量<br>可变参数（…表示，代替数组使用起来更方便）：只能放在参数列表最后；调用含可变参数的方法时编译器为该可变参数隐式的创建一个数组对象。所以在方法体中以数组形式访问。</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>当有若干个变量参与运算时，结果类型取决于这些变量中表示范围最大的那个变量类型。比如，参与运算的变量中，有int，有double，有short，那么最后的结果就是double</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>一元操作符（有一个变量参与的操作符）如： ! , &gt; , &lt; , = , instanceOf<br>二元操作符（有两个变量参与的操作符）+ , - , * , /<br>元，表示变量</p><h3 id="取模运算"><a href="#取模运算" class="headerlink" title="取模运算"></a>取模运算</h3><p>余数的作用，可以实现循环取连续的值。如<br>for (a = 0 ; a &lt; 100 ; a++){<br>System.out.println( a % 5);</p><p>}<br>7 % 3的意义是7中有2个3，余下1.<br>7 % 20 的意义是，7中有0个20，余下7。<br>运算的规律：结果的符号永远与被除数（7）符号相同</p><h3 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h3><p>位移运算可以提高运算速度<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. 左移 &apos;&lt;&lt;&apos;</div><div class="line">a &lt;&lt; n   相当于 a*2n</div><div class="line">2. 右移 &apos;&gt;&gt;&apos;</div><div class="line">a &gt;&gt; n   相当于 a/2n</div></pre></td></tr></table></figure><p></p><h3 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h3><h4 id="按位与-‘-amp-’"><a href="#按位与-‘-amp-’" class="headerlink" title="按位与 ‘&amp;’"></a>按位与 ‘&amp;’</h4><p>两个都是1，结果才是1，串联关系。例如： 1&amp;0 = 0 ;1&amp;1= 1;<br>0xff0000ff &amp; 0x12345678 = 0x12000078<br>16进制f = 2进制 1111<br>与运算可以用于取段位。</p><h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或 |"></a>按位或 |</h4><p>只要有一个是1，结果就是1，并联关系。例如：1|1 = 1;1|0 = 1;<br>0xff0000ff | 0x12345678 = 0xff3456ff</p><h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或 ^"></a>按位异或 ^</h4><p>不同为1，相同为0，比较关系。例如：1^1 =0;1^0 = 1;</p><h3 id="取反"><a href="#取反" class="headerlink" title="取反 ~"></a>取反 ~</h3><p>00000000 00000000 00000000 00000101 这是5<br>11111111 11111111 11111111 11111010 这是5取反的结果-6</p><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><p>3&amp;5 = ？<br>3: 0x00000011 ——– 1x2^1 + 1x2^0 = 2 + 1 = 3<br>5: 0x00000101 ——– 1x2^2 + 1x2^0 = 4 + 1 = 5<br>&amp;: 0x00000001 ——– 1</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>在计算机系统中，数值一律用补码来表示（存储）。<br>补码的好处：<br>使用补码可以将符号位和其他位统一处理（可以符号位运算）<br>减法可以按照加法来处理<br>补码的原理：<br>利用溢出来实现减法变加法<br>如：<br>10进制：<br>计算9 9– 44 = ？<br>-44的反码是55（10机制的最大值是9减去4得到）<br>-44的补码是55+1 = 56<br>上式的计算可以变成：9 9+ 56（-44的反码）=155<br>溢出舍弃 = 55<br>2进制同理：<br>计算 - 1 + 2的结果<br>-1 1111 1111（补码）<br>2 0000 0010（补码）<br>1 0000 0001（补码结果</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><h4 id="For"><a href="#For" class="headerlink" title="For"></a>For</h4><p>在知道循环次数的条件下使用</p><h4 id="While"><a href="#While" class="headerlink" title="While"></a>While</h4><p>在不知道循环次数的条件下使用</p><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>跳出循环用 break；<br>跳出本次循环用 continue；</p><h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><h4 id="switch（变量）"><a href="#switch（变量）" class="headerlink" title="switch（变量）"></a>switch（变量）</h4><p>变量类型为：byte，short，int，char，enum</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>表示静态的，内存中有唯一的一份，其他成员公用的资源。放在静态区<br>生命周期和JVM一致，不会被回收<br>static不可以修饰局部变量，局部变量放在栈中会频繁的生死<br>static方法必须使用static变量也和生命周期有关。区域A能使用区域B的原则是：区域B的生命周期 &gt;=区域A的生命周期</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this只存在于方法中<br>编译器暗中传递的操作此方法的对象的引用。谁调用了这个方法，this就指谁<br>用于调用对象的其他成员，一般可以省略<br>每当启动一个线程的时候，JVM就为他分配一个栈。栈是以帧为单位保存当前运行的状态。每当调用一个方法时。JVM会在对应的栈中压入一个帧，执行方法时，他使用这个帧存储参数、局部变量、this。<br>this（）用来在构造器中调用构造器，构造器中只能调用一次构造器，并且必须在第一行调用</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super只存在于方法中<br>编译器暗中传递的操作此方法的的对象的父类的引用<br>用于调用父类方法<br>super（）用来在构造器重调用父类构造器，只能调用一次，并且必须在第一行调用</p><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>解决类命名冲突问题<br>域名的反转<br>包名小写<br>lang是language缩写lang包表示Java自带的语言包<br>io是input/output缩写io包表示java的输入输出流<br>文件打包 jar –cvf xx.jar<em>.</em>例如：jar –cvf class.jar Foo.class Bar.class</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final修饰数据，表示数据不变，是个常量<br>final修饰引用，表示引用指向不可变<br>final修饰方法，表示方法不可被重写，是不变的<br>final 修饰类，表示类不可以被继承，断子绝孙<br>局部内部类访问同一个方法中的局部变量。那个局部变量必须是final修饰的。原因是： 局部变量的生命周期小于内部类的生命周期。解决的方法是拷贝一个变量副本到内部类，语法上是同一个变量。为了这两个变量一致性，用final来修饰。用final保持不可变的方法来解决一致性的问题。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>为了防止编译器对代码优化<br>每次都从主存中提取变量，防止多线程时，变量被改变，而用的仍然是线程中旧的拷贝版本的数据</p><h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p>修饰不想被序列化的变量</p><h2 id="数组array"><a href="#数组array" class="headerlink" title="数组array"></a>数组array</h2><p>对应的工具类Arrays包含了sort、copy、binarySearch、asList（不可改变大小的List）等方法<br>数组时效率最高的容器。在固定尺寸的情况下，一定要用数组<br>数组的拷贝System.lang.arrayCopy();效率最高。用的事拷贝整块内存的方式<br>数组的内存模型（二维数组）：int[][] scores = new int[3][2];<br>多维数组的length以最外层的大小为准：socres.length = 3;<br><img src="http://7xoxmg.com1.z0.glb.clouddn.com/array.jpg" alt=""></p><h2 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h2><p>private：私有权限<br>default（friendly，什么也不写）：包权限<br>protected：继承权限<br>public：公共权限</p><hr><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>具体事物的抽象<br>体现了很好的封装<br>由数据（成员变量）和方法构成<br>命名约定：类名首字母大写，类中成员名首字母小写（成员变量、方法）单词间驼峰原则<br>抽象类：有abstract方法的类</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>人认识世界中事物的基本单位<br>用引用操纵对象，相当于遥控器操纵电视</p><h4 id="生成对象的方法"><a href="#生成对象的方法" class="headerlink" title="生成对象的方法"></a>生成对象的方法</h4><h5 id="反射法"><a href="#反射法" class="headerlink" title="反射法"></a>反射法</h5><p>Class.forName（”Foo”）.newInstance（）;<br>此方法动态性强，主要用于配置文件，后期给定对象</p><h5 id="New法"><a href="#New法" class="headerlink" title="New法"></a>New法</h5><p>Foo foo = new Foo（）；<br>new 对象执行的流程:<br>classloadeer载入类<br>在堆中开辟空间<br>如果有静态块，则由父类到子类先把静态块运行完。再往下面走。具体如下：父类·静态属性 &gt; 父类·静态块 &gt; 子类·静态属性 &gt; 子类·静态块<br>父类的构造方法super（）；//父类属性，父类构造器方法体<br>总之：由内向外，（开辟空间、属性、构造器依次运行）层层构造。<br>总体顺序：<br>静态 &gt; main入口（如果类中有的话）&gt; 非静态。<br>静态：按由内向外、由上到下的顺序执行。<br>非静态：按属性-&gt; 构造器顺序执行</p><h4 id="对象初始化与清理"><a href="#对象初始化与清理" class="headerlink" title="对象初始化与清理"></a>对象初始化与清理</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>可以不初始化，在堆中创建时会赋上默认值</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>必须初始化</p><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>赋空值的时候，JVM会自动回收new出的空间</p><h2 id="复用类"><a href="#复用类" class="headerlink" title="复用类"></a>复用类</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过继承其他类来复用</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>通过包含其他引用来复用</p><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><h4 id="浅clone"><a href="#浅clone" class="headerlink" title="浅clone"></a>浅clone</h4><p>只clone当前类的属性。<br>适用于clone只含有基本类型成员的对象</p><h4 id="深clone"><a href="#深clone" class="headerlink" title="深clone"></a>深clone</h4><p>clone 所有属性，包括引用对象的属性。<br>适用于clone 包含有引用类型成员的对象</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态和继承的关系：有了继承然后才有了多态，继承是为了复用功能，多态是为了变化功能<br>概念：同一操作，不同结果（体现在方法上）<br>本质：实现了动态绑定（运行时绑定、后期绑定）<br>体现：主要体现在方法重写上<br>特点：父类引用指向子类对象</p><h2 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h2><h3 id="标识接口"><a href="#标识接口" class="headerlink" title="标识接口"></a>标识接口</h3><p>serializable、cloneable</p><h3 id="普通接口"><a href="#普通接口" class="headerlink" title="普通接口"></a>普通接口</h3><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><h4 id="重载overLoard"><a href="#重载overLoard" class="headerlink" title="重载overLoard"></a>重载overLoard</h4><p>重新载入。重载的是参数<br>名字相同<br>参数列表不同<br>返回值无要求（一般相同）<br>权限无要求</p><h4 id="重写overwrite"><a href="#重写overwrite" class="headerlink" title="重写overwrite"></a>重写overwrite</h4><p>重写父类方法。重写的是方法体中的内容<br>所有东西都相同（名字、参数列表、返回值）<br>方法体中的内容不同<br>权限不能萎缩</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽取共同的东西。面向对象语言最大的本事是 应对变化。<br>通过抽象的方式来应对变化，哪里变化就抽象哪里。<br>所有涉及到 extend 和 implement 的东西，都是抽象。 因为父类有共同的东西。<br>java中到处都是抽象。</p><h3 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h3><h4 id="属性的抽象"><a href="#属性的抽象" class="headerlink" title="属性的抽象"></a>属性的抽象</h4><p>把共有的属性抽象到父类。 如：Android中的 interface BaseColumns</p><h4 id="方法的抽象"><a href="#方法的抽象" class="headerlink" title="方法的抽象"></a>方法的抽象</h4><p>把共有的行为抽象到父类。 如：android中的 interface Observer</p><h4 id="属性，方法混合抽象"><a href="#属性，方法混合抽象" class="headerlink" title="属性，方法混合抽象"></a>属性，方法混合抽象</h4><p>把共有的属性，方法抽象到父类。 这个的例子非常多。 如： android中的 context ， View，等等。</p><hr><h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><p>Java虚拟机启动后会启动一个gc线程，gc线程会不定时的进行垃圾回收工作。<br>什么对象会被回收？</p><h2 id="引用计数方式回收"><a href="#引用计数方式回收" class="headerlink" title="引用计数方式回收"></a>引用计数方式回收</h2><p>某个对象有一个引用，计数器加1；引用断开，计数器减1。<br>gc线程工作时发现引用计数器为0的对象就会回收它。</p><h2 id="根遍历方式回收"><a href="#根遍历方式回收" class="headerlink" title="根遍历方式回收"></a>根遍历方式回收</h2><p>入口根遍历如果发现有没有被引用的对象就回收它。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用 StrongReference"></a>强引用 StrongReference</h3><p>某个对象只有强引用时，它就永远不会被回收。</p><h3 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用 SoftReference"></a>软引用 SoftReference</h3><p>某个对象只有软引用时，当内存不够时，会回收这个对象。如果内存仍然不够则抛出内存溢出异常。</p><h3 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用 WeakReference"></a>弱引用 WeakReference</h3><p>某个对象只有弱引用时，当gc线程回收的时候，它一定会被回收。</p><h3 id="幽灵引用-PhantomReference"><a href="#幽灵引用-PhantomReference" class="headerlink" title="幽灵引用 PhantomReference"></a>幽灵引用 PhantomReference</h3><p>配合ReferenceQueue可以让我们准确地知道对象何时被从内存中删除。<a href="https://github.com/javalive09/CodeBag/blob/master/sample/src/main/java/com/javalive09/sample/project/raventech/reference.java" target="_blank" rel="noopener">codebag demo</a><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class PhantomReferenceTest &#123;</div><div class="line"> public static void main(String... args)&#123;</div><div class="line">  ReferenceQueue rq = new ReferenceQueue(); </div><div class="line">  A a = new A();</div><div class="line">  a.s =&quot;hello&quot;;</div><div class="line">  Reference r = new PhantomReference(a, rq);</div><div class="line">  a = null;</div><div class="line">  System.gc();	</div><div class="line">  </div><div class="line">  new Thread(new Runnable() &#123;</div><div class="line">  	public void run() &#123;</div><div class="line">  		while(Reference ref = rq.remove != null )  &#123;</div><div class="line">		System.out.println(ref.get());</div><div class="line">  		&#125;</div><div class="line">  	&#125;</div><div class="line">  &#125;).start();</div><div class="line"> &#125; </div><div class="line">&#125;</div><div class="line">class A&#123;</div><div class="line"> String s;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="Soft-vs-Weak-vs-Phantom-References"><a href="#Soft-vs-Weak-vs-Phantom-References" class="headerlink" title="Soft vs Weak vs Phantom References"></a>Soft vs Weak vs Phantom References</h3><table><thead><tr><th>Type</th><th>Purpose</th><th>Use</th><th>When GCed</th><th>Implementing Class</th></tr></thead><tbody><tr><td>Strong Reference</td><td>An ordinary reference. Keeps objects alive as long as they are referenced.</td><td>normal reference.</td><td>Any object not pointed to can be reclaimed.</td><td>default</td></tr><tr><td>Soft Reference</td><td>Keeps objects alive provided there’s enough memory.</td><td>to keep objects alive even after clients have removed their references (memory-sensitive caches), in case clients start asking for them again by key.</td><td>After a first gc pass, the JVM decides it still needs to reclaim more space.</td><td>java.lang.ref.SoftReference</td></tr><tr><td>Weak Reference</td><td>Keeps objects alive only while they’re in use (reachable) by clients.</td><td>Containers that automatically delete objects no longer in use.</td><td>After gc determines the object is only weakly reachable</td><td>java.lang.ref.WeakReference java.util.WeakHashMap</td></tr><tr><td>Phantom Reference</td><td>Lets you clean up after finalization but before the space is reclaimed (replaces or augments the use of finalize())</td><td>Special clean up processing</td><td>After finalization.</td><td>java.lang.ref.PhantomReference</td></tr></tbody></table><hr><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>在java中引入exception目的是 增加对程序出现异常的管控。</p><h2 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h2><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>虚拟机层面的错误，这种错误非常严重，错误所在线程会直接崩溃。</p><h3 id="CheckException"><a href="#CheckException" class="headerlink" title="CheckException"></a>CheckException</h3><p>一种概念，并非具体异常，除了RuntimeException都属于CheckException。API层面的错误，提供的API不能保证百分百的稳定性，有可能会出现某些问题，这种API会强制要求程序员必须 try catch 捕获，所以程序不会崩溃。<br>常见的如：<br>IOException<br>JSONException<br>SQLException<br>TimeoutException<br>XmlPullParserException</p><h3 id="RunTimeException"><a href="#RunTimeException" class="headerlink" title="RunTimeException"></a>RunTimeException</h3><p>程序编写层面出现的错误，这种错误比较严重，一般是逻辑或不符合规范造成的，程序所在线程会崩溃。<br>出现了这种错误，说明程序有严重的问题，程序员需要对程序编写逻辑重新处理。<br>常见的如：<br>NullPointerException<br>NumberFormatException<br>ClassCastException<br>StringIndexOutOfBoundsException<br>ArrayIndexOutOfBoundsException<br>IllegalArgumentException<br>ArithmeticException</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>Throwable<br>|<strong>_</strong>Error<br>|<strong>_</strong>Exception<br><strong><strong>__</strong></strong>|<strong><strong> RuntimeException<br><strong>__</strong></strong></strong>|<em>__</em> other（checkException）</p><blockquote><p>如何获取及保存exception log 使用UncaughtExceptionHandler来捕获unchecked异常保存到SDcard，到一定大小后发送，然后重置。</p></blockquote><p>在程序入口处， application的 onCreate() 或者Activity的onCreate()里面加入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Thread.setDefaultUncaughtExceptionHandler(new CrashHandler());</div></pre></td></tr></table></figure><p>实现UncaughtExceptionHandler中的uncaughtException方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CrashHandler implements UncaughtExceptionHandler &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void uncaughtException(Thread thread, Throwable ex) &#123;</div><div class="line">		//处理异常</div><div class="line">		Log.e(&quot;崩溃&quot;,thread.getName()+ex.toString());</div><div class="line">		//发送到服务器</div><div class="line">		//dialog提醒</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p></div><div></div><div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2014/02/28/开源App/" rel="next" title="开源App"><i class="fa fa-chevron-left"></i> 开源App</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2014/04/16/Java2/" rel="prev" title="Java2">Java2 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div><div class="ds-thread" data-thread-key="<%- page.path %>" data-title="<%- page.title %>" data-url="<%- page.permalink %>"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://7xoxmg.com1.z0.glb.clouddn.com/avatar.jpg" alt="peter"><p class="site-author-name" itemprop="name">peter</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">日志</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/javalive09" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="http://stackoverflow.com/users/4674672/peter-zhang" target="_blank" title="S.O."><i class="fa fa-fw fa-stack-overflow"></i> S.O. </a></span><span class="links-of-author-item"><a href="https://200code.com/sites/" target="_blank" title="在线工具"><i class="fa fa-fw fa-globe"></i> 在线工具</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本类型"><span class="nav-number">1.</span> <span class="nav-text">基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型"><span class="nav-number">1.1.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本数据类型（4类8种，能自动装箱）"><span class="nav-number">1.1.1.</span> <span class="nav-text">基本数据类型（4类8种，能自动装箱）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#整形"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">整形</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#byte（8-bit，1个字节-128-127）"><span class="nav-number">1.1.1.1.1.</span> <span class="nav-text">byte（8 bit，1个字节 -128~127）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#short（16-bit，-2个字节）"><span class="nav-number">1.1.1.1.2.</span> <span class="nav-text">short（16 bit， 2个字节）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int（32-bit，4个字节）"><span class="nav-number">1.1.1.1.3.</span> <span class="nav-text">int（32 bit，4个字节）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#long（64-bit，8个字节）"><span class="nav-number">1.1.1.1.4.</span> <span class="nav-text">long（64 bit，8个字节）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浮点型"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">浮点型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#float（32bit，-4个字节）"><span class="nav-number">1.1.1.2.1.</span> <span class="nav-text">float（32bit， 4个字节）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#double（64bit，8个字节-）"><span class="nav-number">1.1.1.2.2.</span> <span class="nav-text">double（64bit，8个字节 ）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符型"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">字符型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#char（16-bit，-2个字节）"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">char（16 bit， 2个字节）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布尔型"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">布尔型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#boolean（1-bit）"><span class="nav-number">1.1.1.4.1.</span> <span class="nav-text">boolean（1 bit）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制转换"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">强制转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#正数"><span class="nav-number">1.1.1.5.1.</span> <span class="nav-text">正数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#负数"><span class="nav-number">1.1.1.5.2.</span> <span class="nav-text">负数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十六进制字符串转换成int方法"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">十六进制字符串转换成int方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用数据类型"><span class="nav-number">1.1.2.</span> <span class="nav-text">引用数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类（class）"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">类（class）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#包装类（能自动拆箱）"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">包装类（能自动拆箱）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#枚举类"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其他类"><span class="nav-number">1.1.2.1.3.</span> <span class="nav-text">其他类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口（interface）"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">接口（interface）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String字符串"><span class="nav-number">1.1.3.</span> <span class="nav-text">String字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuilder"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">StringBuilder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">StringBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String占用字节数"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">String占用字节数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于分隔"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">关于分隔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象个数"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">对象个数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题"><span class="nav-number">1.1.4.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#int-和-Integer-有什么区别？"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">int 和 Integer 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#short-s1-1-s1-s1-1-有什么错"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">short s1 = 1; s1 = s1 + 1;有什么错?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#char型变量中能不能存贮一个中文汉字"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">char型变量中能不能存贮一个中文汉字?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java支持的数据类型有哪些？什么是自动拆装箱？"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">Java支持的数据类型有哪些？什么是自动拆装箱？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码知识"><span class="nav-number">1.2.</span> <span class="nav-text">编码知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bit（binary-digit二进制数，比特）"><span class="nav-number">1.2.1.</span> <span class="nav-text">Bit（binary digit二进制数，比特）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASCII"><span class="nav-number">1.2.2.</span> <span class="nav-text">ASCII</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ISO8859-1-（8位二进制，1个byte字节表示字符）"><span class="nav-number">1.2.3.</span> <span class="nav-text">ISO8859-1 （8位二进制，1个byte字节表示字符）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode（16位二进制，2个byte字节表示字符，又叫万国码）java编码格式"><span class="nav-number">1.2.4.</span> <span class="nav-text">Unicode（16位二进制，2个byte字节表示字符，又叫万国码）java编码格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GBK"><span class="nav-number">1.2.5.</span> <span class="nav-text">GBK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#base64-编码"><span class="nav-number">1.2.6.</span> <span class="nav-text">base64 编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于字母"><span class="nav-number">1.2.7.</span> <span class="nav-text">关于字母</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于变量"><span class="nav-number">1.3.</span> <span class="nav-text">关于变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命名规范"><span class="nav-number">1.3.1.</span> <span class="nav-text">命名规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分类"><span class="nav-number">1.3.2.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态变量（内存低地址区域，静态区）"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">静态变量（内存低地址区域，静态区）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员变量（存放在Heap堆中）"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">成员变量（存放在Heap堆中）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部变量（local-variables内存高地址区域，存放在Stack栈中）"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">局部变量（local variables内存高地址区域，存放在Stack栈中）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算"><span class="nav-number">1.3.3.</span> <span class="nav-text">运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符"><span class="nav-number">1.4.</span> <span class="nav-text">操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分类-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取模运算"><span class="nav-number">1.4.2.</span> <span class="nav-text">取模运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位移运算"><span class="nav-number">1.4.3.</span> <span class="nav-text">位移运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按位运算"><span class="nav-number">1.4.4.</span> <span class="nav-text">按位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#按位与-‘-amp-’"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">按位与 ‘&amp;’</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按位或"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">按位或 |</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按位异或"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">按位异或 ^</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取反"><span class="nav-number">1.4.5.</span> <span class="nav-text">取反 ~</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-1"><span class="nav-number">1.4.6.</span> <span class="nav-text">面试题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补码"><span class="nav-number">1.5.</span> <span class="nav-text">补码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程控制"><span class="nav-number">1.6.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#循环控制"><span class="nav-number">1.6.1.</span> <span class="nav-text">循环控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#For"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">For</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#While"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">While</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件控制"><span class="nav-number">1.6.2.</span> <span class="nav-text">条件控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if-else"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">if else</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch（变量）"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">switch（变量）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字"><span class="nav-number">1.7.</span> <span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">1.7.1.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">1.7.2.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">1.7.3.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#package"><span class="nav-number">1.7.4.</span> <span class="nav-text">package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">1.7.5.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">1.7.6.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transient"><span class="nav-number">1.7.7.</span> <span class="nav-text">transient</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组array"><span class="nav-number">1.8.</span> <span class="nav-text">数组array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问权限控制"><span class="nav-number">1.9.</span> <span class="nav-text">访问权限控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象"><span class="nav-number">2.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象"><span class="nav-number">2.1.</span> <span class="nav-text">类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类"><span class="nav-number">2.1.1.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-number">2.1.2.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成对象的方法"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">生成对象的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#反射法"><span class="nav-number">2.1.2.1.1.</span> <span class="nav-text">反射法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#New法"><span class="nav-number">2.1.2.1.2.</span> <span class="nav-text">New法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象初始化与清理"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">对象初始化与清理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#成员变量"><span class="nav-number">2.1.2.2.1.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#局部变量"><span class="nav-number">2.1.2.2.2.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#引用"><span class="nav-number">2.1.2.2.3.</span> <span class="nav-text">引用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复用类"><span class="nav-number">2.2.</span> <span class="nav-text">复用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">2.2.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合"><span class="nav-number">2.2.2.</span> <span class="nav-text">组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#克隆"><span class="nav-number">2.2.3.</span> <span class="nav-text">克隆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#浅clone"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">浅clone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#深clone"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">深clone</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">2.3.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口interface"><span class="nav-number">2.4.</span> <span class="nav-text">接口interface</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标识接口"><span class="nav-number">2.4.1.</span> <span class="nav-text">标识接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通接口"><span class="nav-number">2.4.2.</span> <span class="nav-text">普通接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载和重写"><span class="nav-number">2.4.3.</span> <span class="nav-text">重载和重写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重载overLoard"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">重载overLoard</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重写overwrite"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">重写overwrite</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象"><span class="nav-number">2.5.</span> <span class="nav-text">抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分类-2"><span class="nav-number">2.5.1.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性的抽象"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">属性的抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法的抽象"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">方法的抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性，方法混合抽象"><span class="nav-number">2.5.1.3.</span> <span class="nav-text">属性，方法混合抽象</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存回收"><span class="nav-number">3.</span> <span class="nav-text">内存回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引用计数方式回收"><span class="nav-number">3.1.</span> <span class="nav-text">引用计数方式回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#根遍历方式回收"><span class="nav-number">3.2.</span> <span class="nav-text">根遍历方式回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用类型"><span class="nav-number">3.3.</span> <span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#强引用-StrongReference"><span class="nav-number">3.3.1.</span> <span class="nav-text">强引用 StrongReference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软引用-SoftReference"><span class="nav-number">3.3.2.</span> <span class="nav-text">软引用 SoftReference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#弱引用-WeakReference"><span class="nav-number">3.3.3.</span> <span class="nav-text">弱引用 WeakReference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#幽灵引用-PhantomReference"><span class="nav-number">3.3.4.</span> <span class="nav-text">幽灵引用 PhantomReference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Soft-vs-Weak-vs-Phantom-References"><span class="nav-number">3.3.5.</span> <span class="nav-text">Soft vs Weak vs Phantom References</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异常处理"><span class="nav-number">4.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分类-3"><span class="nav-number">4.1.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Error"><span class="nav-number">4.1.1.</span> <span class="nav-text">Error</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CheckException"><span class="nav-number">4.1.2.</span> <span class="nav-text">CheckException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunTimeException"><span class="nav-number">4.1.3.</span> <span class="nav-text">RunTimeException</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构"><span class="nav-number">4.2.</span> <span class="nav-text">结构</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">peter</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script></body></html>