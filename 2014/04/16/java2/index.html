<html><head><title>java2</title><meta name="keywords" content="My Blog, Spider Bitch!"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=2" rel="stylesheet" type="text/css"><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"></head><body><h2 class="title">java2</h2><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程和进程的关系"><a href="#线程和进程的关系" class="headerlink" title="线程和进程的关系"></a>线程和进程的关系</h2><p>线程寄生在进程中。一个进程中可以有多个线程。<br>进程本质上是一个执行的程序。<br>线程是多任务处理的最小单位。<br>多线程比多进程消耗更少的资源。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在单个程序中同时执行多个不同的任务。多线程的目的是为了最大限度的利用cpu资源。<br>当程序运行时，会自动产生一个主线程，main方法就在这个主线程中运行。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="http://7xoxmg.com1.z0.glb.clouddn.com/threadlife.jpg" alt=""></p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p><img src="http://7xoxmg.com1.z0.glb.clouddn.com/threadlogic.jpg" alt=""></p><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>睡眠</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>加入启动它的线程，让异步变同步</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>让出，让给相同优先级的其他线程执行</p><h3 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h3><p>notify（），通知其他线程使用cpu资源，一般写在线程执行完后。 （必须在synchronized块或方法中）<br>notify（），wait（），synchronized 是一个组合。他们一定是配合使用的，来进行线程间交互。</p><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><p>sleep不释放对象锁（占着cup资源的茅坑不拉屎，睡觉去了）<br>wait 释放对象锁（交出cup资源, monitor锁资源，进入等待池）<br>wait 使用时线程必须有对象锁。（必须在synchronized块或方法中）</p><h3 id="synchronized-的几种使用场景"><a href="#synchronized-的几种使用场景" class="headerlink" title="synchronized 的几种使用场景"></a>synchronized 的几种使用场景</h3><p>对象中的同步方法: 锁是对象本身。<br>静态的同步方法：锁是方法所在的类class对象。</p><h3 id="如何做并发加法"><a href="#如何做并发加法" class="headerlink" title="如何做并发加法"></a>如何做并发加法</h3><h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>AtomicLong<br>AtomicInteger<br>incrementAndGet() decrementAndGet()</p><h4 id="java8-并发加法器"><a href="#java8-并发加法器" class="headerlink" title="java8 并发加法器"></a>java8 并发加法器</h4><p>LongAdder<br>DoubleAdder<br>Android N之后支持java 8</p><hr><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>缓冲流速度快的原因： 不用每次都频繁的和硬件设备（扇区）进行读写。和硬件设备读写最影响速度</p><h2 id="InputStream-read方法"><a href="#InputStream-read方法" class="headerlink" title="InputStream read方法"></a>InputStream read方法</h2><p>提供的两种都是将流读入byte[]中。无参Read（），byte[0] &amp; 0xff 由于我们需要的是2进制内容，而不是补码，所以要进行高位清零，&amp;0xff可以实现清零功能。返回int类型的内容。其内部也是调用有参的read方法，只不过是一个byte，一个byte的读，然后转成int 返回。</p><h2 id="OutputStream-write方法"><a href="#OutputStream-write方法" class="headerlink" title="OutputStream write方法"></a>OutputStream write方法</h2><p>都是将byte[]、int(里面装byte型内容)写入流中。</p><blockquote><p>注：byte[]相当于转移流的小容器，小桶<br>ByteArrayOutputstream（）含有可扩展的byte[]属性。用于装内容。流写入内存中的操作。把流变成数组。Bytearray out<br>ByteArrayInputstream（）把数组变成流。Bytearray in 把内存作为输出方式</p></blockquote><hr><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>容器中只能存放对象</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>对应的工具类Collections，包含排序、洗牌等操作</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>本质是Object数组<br>private transient Object[] elementData<br>默认数组的长度为10<br>add时超过10则数组长度增加原来长度的一半<br>list变数组：（T[]）list.toArray(newT[list.size()]);</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>本质是双向的链表<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private static  class  Node&lt;E&gt;&#123;</div><div class="line"></div><div class="line">        E item;</div><div class="line"></div><div class="line">        Node&lt;E&gt; next;</div><div class="line"></div><div class="line">       Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>add是new Node 节点，然后关联起来。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>和数学上的集合的概念相同，元素不重复</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>本质是HashMap，无序的set<br>private transient HashMap<e ,="" object="">map ;<br>add时用key来存值，value为一个object对象<br>可以用来做随机抽奖的容器。</e></p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>本质是 TreeMap，有序的set<br>构造时可以加入comparator 参数，自定义定义排序规则<br>add时用key来存值，value为一个object对象</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>key无序的map，本质是Entry数组和单向链表的结合。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">transient Entry[] table</div><div class="line">static Entry &lt;K,V&gt; implementsMap.Entry&lt;K,V&gt;&#123;</div><div class="line"></div><div class="line">       final K key;</div><div class="line"></div><div class="line">       V value;</div><div class="line"></div><div class="line">       Entry&lt;K,V&gt; next;</div><div class="line"></div><div class="line">       Final int hash;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>默认数组长度为16<br>增加容量时2倍增加<br>put元素时，会先对比hash值和equals内容。判断键值是否相等。<br>可以用来做统计文字出现次数的容器<br><img src="http://7xoxmg.com1.z0.glb.clouddn.com/hashmap.jpg" alt=""></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>key 有序的map</p><h2 id="为什么重写类中的equals方法必须重写hashcode"><a href="#为什么重写类中的equals方法必须重写hashcode" class="headerlink" title="为什么重写类中的equals方法必须重写hashcode"></a>为什么重写类中的equals方法必须重写hashcode</h2><p>将对象放到集合（set、map）时会涉及对比hashcode的情况。如果不重写调用的hashcode方法则会调用object类的hashcode方法（对象的地址），这样会造成内容相同的对象，在内存地址不同的情况下，会被存入set、map中。但是集合中要求对象中的内容不能重复的。这样就矛盾了</p><hr><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="静态内部类（Static-Inner-Class）"><a href="#静态内部类（Static-Inner-Class）" class="headerlink" title="静态内部类（Static Inner Class）"></a>静态内部类（Static Inner Class）</h2><p>static 修饰的内部类<br>只能访问外部类的静态成员变量与静态方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Outerclass.InnerClass inner = newOuterClass.InnerClass();</div></pre></td></tr></table></figure><p></p><p>静态内部类和非静态内部类的唯一区别是：<br>静态内部类没有了指向外部类的引用<br>如果内部类不会引用到外部类的东西的话，强烈建议使用静态内部类，因为这样更节省资源，减少内部类指向外部类的引用——Effective Java</p><h2 id="成员内部类（Member-Inner-Class）"><a href="#成员内部类（Member-Inner-Class）" class="headerlink" title="成员内部类（Member Inner Class）"></a>成员内部类（Member Inner Class）</h2><p>和成员同一级别的内部类</p><p>可以访问外部类的所有成员（成员变量、方法）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OuterClass.InnerClass inner = new OuterClass().newInnerClass();</div></pre></td></tr></table></figure><p></p><p>可以加括号理解(new OutClass()).newInnerClass();</p><h2 id="局部内部类（Local-Inner-Class）"><a href="#局部内部类（Local-Inner-Class）" class="headerlink" title="局部内部类（Local Inner Class）"></a>局部内部类（Local Inner Class）</h2><p>方法中的内部类<br>访问外部类成员变量的方式：OuterClass.this.a;<br>只能访问所在方法中的final变量</p><h2 id="匿名内部类（Anonymous-Inner-Class）"><a href="#匿名内部类（Anonymous-Inner-Class）" class="headerlink" title="匿名内部类（Anonymous Inner Class）"></a>匿名内部类（Anonymous Inner Class）</h2><p>隐式的继承一个父类或实现一个借口<br>自动向上转型</p><h2 id="引入内部类要解决的问题是"><a href="#引入内部类要解决的问题是" class="headerlink" title="引入内部类要解决的问题是"></a>引入内部类要解决的问题是</h2><p>一个类可以访问另一个类的私有成员（封装性）<br>让Java可以实现多继承</p><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="undefined";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div></body></html>