<!doctype html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="URI（uniformresource identifier）和URL（universal resource Loactor）的区别一个URI定义了一种资源，它是一个定位符。一个URI由两部分组成： scheme （URI协议名）：scheme-specific-part（URI协议对应的内容）一个URL由三部分组成：scheme（协议）：// 主机IP地址 / 资源具体地址一个URI是一个URL"><meta property="og:type" content="article"><meta property="og:title" content="网络"><meta property="og:url" content="http://yoursite.com/2017/02/11/网络/index.html"><meta property="og:site_name" content="200code"><meta property="og:description" content="URI（uniformresource identifier）和URL（universal resource Loactor）的区别一个URI定义了一种资源，它是一个定位符。一个URI由两部分组成： scheme （URI协议名）：scheme-specific-part（URI协议对应的内容）一个URL由三部分组成：scheme（协议）：// 主机IP地址 / 资源具体地址一个URI是一个URL"><meta property="og:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/tcp_client.png"><meta property="og:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/tcp_server.png"><meta property="og:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/tcp.jpg"><meta property="og:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/ssl_handshake_rsa.jpg"><meta property="og:updated_time" content="2017-07-13T07:15:47.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="网络"><meta name="twitter:description" content="URI（uniformresource identifier）和URL（universal resource Loactor）的区别一个URI定义了一种资源，它是一个定位符。一个URI由两部分组成： scheme （URI协议名）：scheme-specific-part（URI协议对应的内容）一个URL由三部分组成：scheme（协议）：// 主机IP地址 / 资源具体地址一个URI是一个URL"><meta name="twitter:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/tcp_client.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"always"},fancybox:!1,motion:!1,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2017/02/11/网络/"><title>网络 | 200code</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?afd325d3333e718fc607b569c45d57a4";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">200code</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/11/网络/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="peter"><meta itemprop="description" content=""><meta itemprop="image" content="http://7xoxmg.com1.z0.glb.clouddn.com/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="200code"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="200code" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline">网络</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-11T08:52:34+08:00">2017-02-11 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a class="cloud-tie-join-count" href="/2017/02/11/网络/#comments" itemprop="discussionUrl"><span class="post-comments-count join-count" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="URI（uniformresource-identifier）和URL（universal-resource-Loactor）的区别"><a href="#URI（uniformresource-identifier）和URL（universal-resource-Loactor）的区别" class="headerlink" title="URI（uniformresource identifier）和URL（universal resource Loactor）的区别"></a>URI（uniformresource identifier）和URL（universal resource Loactor）的区别</h1><p>一个URI定义了一种资源，它是一个定位符。<br>一个URI由两部分组成： scheme （URI协议名）：scheme-specific-part（URI协议对应的内容）<br>一个URL由三部分组成：scheme（协议）：// 主机IP地址 / 资源具体地址<br>一个URI是一个URL或URN<br>URL、URN是URI的子集<br>当对某种资源是URL还是URI产生疑惑时，用URI来定义它</p><hr><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>超文本传输协议，用于网络间传输数据。传输的内容不仅是文本文字，还有图片，程序包，文件等各种格式的数据。<br>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>请求行（负责请求的方式），消息头（负责请求的协议），正文（负责请求的内容）</p><ul><li>request-line : Method Request-URI http-version</li><li>Request-Header-Fields : General-Header Request-Header Entity-Header</li><li>Entity-Body</li></ul><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>状态行（负责响应的状态提示），消息头（负责相应的协议），正文（负责响应的内容）</p><ul><li>Status-Line : http-version Status-Code Reason-Phrase</li><li>Response Header Fields : General-Header Response-Header Entity-Header</li><li>Entity-Body</li></ul><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><table><thead><tr><th>状态码</th><th>类别</th><th>详情</th></tr></thead><tbody><tr><td>1XX</td><td>informational(信息性)</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>success(成功)</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>redirection(重定向)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>client error(客户端错误)</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>server error(服务器端错误)</td><td>服务器处理请求出错</td></tr></tbody></table><table><thead><tr><th>状态码</th><th>详情</th><th>场景</th></tr></thead><tbody><tr><td>204</td><td>请求处理成功，但没有资源可返回。返回的响应报文中不含实体，也不允许含实体，从浏览器发出请求，返回204，则浏览器显示的页面不更新</td><td>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</td></tr><tr><td>206</td><td>表示客户端进行了范围请求，响应报文中包含content-Range指定范围的实体内容</td><td></td></tr><tr><td>301</td><td>永久重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</td><td></td></tr><tr><td>302</td><td>临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</td><td>已移动的资源对应的 URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。</td></tr><tr><td>303</td><td>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。</td><td>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。</td></tr><tr><td>304</td><td>该状态码表示客户端发送附带条件的请求 时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。</td><td>条件请求，缓存无需更新的返回码</td></tr><tr><td>307</td><td>临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。</td><td>307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</td></tr><tr><td>400</td><td>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</td><td></td></tr><tr><td>401</td><td>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用 户认证失败。</td><td>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</td></tr><tr><td>403</td><td>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。</td><td>未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。</td></tr><tr><td>404</td><td>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</td><td></td></tr><tr><td>412</td><td>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。</td><td>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。</td></tr><tr><td>500</td><td>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</td><td>服务器内部资源出故障</td></tr><tr><td>503</td><td>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。</td><td>服务器正在忙</td></tr></tbody></table><h2 id="http-header-fileds"><a href="#http-header-fileds" class="headerlink" title="http header fileds"></a>http header fileds</h2><h3 id="General-Header-Fields"><a href="#General-Header-Fields" class="headerlink" title="General Header Fields"></a>General Header Fields</h3><ul><li>Cache-Control</li><li>Connection</li><li>Date</li><li>Pragma</li><li>Trailer</li><li>Transfer-Encoding</li><li>Upgrade</li><li>Via</li><li>Warning</li></ul><h3 id="Request-Header-Fields"><a href="#Request-Header-Fields" class="headerlink" title="Request Header Fields"></a>Request Header Fields</h3><ul><li>Accept</li><li>Accept-Charset</li><li>Accept-Encoding</li><li>Accept-Language</li><li>Authorization</li><li>Expect</li><li>From</li><li>Host</li><li>If-Match</li><li>If-Modified-Since</li><li>If-None-Match</li><li>If-Range</li><li>If-Unmodified-Since</li><li>Max-Forwards</li><li>Proxy-Authorization</li><li>Range</li><li>Referer</li><li>TE</li><li>User-Agent</li></ul><h3 id="Response-Header-Fields"><a href="#Response-Header-Fields" class="headerlink" title="Response Header Fields"></a>Response Header Fields</h3><ul><li>Accept-Ranges</li><li>Age</li><li>ETag</li><li>Location</li><li>Proxy-Authenticate</li><li>Retry-After</li><li>Server</li><li>Vary</li><li>WWW-Authenticate</li></ul><h3 id="Entity-Header-Fields"><a href="#Entity-Header-Fields" class="headerlink" title="Entity Header Fields"></a>Entity Header Fields</h3><ul><li>Content-Encoding</li><li>Content-Language</li><li>Content-Length</li><li>Content-Location</li><li>Content-MD5</li><li>Content-Range</li><li>Content-Type</li><li>Expires</li><li>Last-Modified</li><li>Set-Cookie</li><li>Cookie</li></ul><h3 id="other-Header-Fields"><a href="#other-Header-Fields" class="headerlink" title="other Header Fields"></a>other Header Fields</h3><ul><li>X-Frame-Options</li><li>X-XSS-Protection</li><li>DNT</li><li>P3P</li></ul><h1 id="OSI网络模型"><a href="#OSI网络模型" class="headerlink" title="OSI网络模型"></a>OSI网络模型</h1><p>7层，应用程（经理）：负责写草稿 / 阅读信件 ————— 内容提供或阅读内容<br>6层，表示层（助理）：负责将草稿写成正规格式的信 / 翻译信的内容 —————加解密<br>5层，会话层（秘书）：负责写好信封（收信人地址） / 打开信件 —————建立通讯<br>4层，传输层（司机）：将信带到邮局 / 从邮局拿回信 —————确保数据传输</p><p>3层，网络层（排序工人）： 将信件根据收件地址分类 / 整理分类出信件 —————将发送方的数据传到接收方，路由器<br>2层，数据链路层（包装工人）：将信件包装 / 打开包装 —————管理比特数据，交换机<br>1层，物理层（搬运工人）： 将信件装上车 / 将信件卸下车 —————物理设备，传输高低电压，如电缆</p><hr><h1 id="tcp连接-为什么要进行3次握手，断开为什么要4次握手"><a href="#tcp连接-为什么要进行3次握手，断开为什么要4次握手" class="headerlink" title="tcp连接 为什么要进行3次握手，断开为什么要4次握手"></a>tcp连接 为什么要进行3次握手，断开为什么要4次握手</h1><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><ul><li>A打电话给B，需要询问，你是B么？</li><li>B回答说我是B。</li><li>A堆B说，我找的就是你。<br>至此，A知道找对了B。B也知道A是要找他。<blockquote><p>如果不是3次握手的话，如果是客户端A和服务器B连接的话，A请求连接，B分配资源并回复的话，有可能会是A的失效请求，这样容易造成资源浪费。</p></blockquote></li></ul><p>防止了服务器端的一直等待而浪费资源。所以加了一次需要客户端A确认的操作。</p><p>《计算机网络》中是这样解释的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞</div><div class="line">留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要</div><div class="line">server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server</div><div class="line">发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“</div><div class="line">三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知</div><div class="line">道client并没有要求建立连接。”</div></pre></td></tr></table></figure><p></p><p>相当于打电话时网络运营商连接了错的号码。<br>双方确定连接。<br>之后开始正式的传输数据。</p><h3 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h3><ul><li>A告诉B，我要说的说完了，我要挂电话了。</li><li>B告诉A，好的。</li><li>B告诉A，继续说刚才说一半的事…。我要说的也说完了，我也要挂电话了。</li><li>A告诉B，好的。</li><li>A等30秒后挂电话。<br>TCP是全双工模式，双方确定彼此都要挂断电话后，正式断开连接。<br>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</li></ul><p><img src="http://7xoxmg.com1.z0.glb.clouddn.com/tcp_client.png" alt=""><br><img src="http://7xoxmg.com1.z0.glb.clouddn.com/tcp_server.png" alt=""><br><img src="http://7xoxmg.com1.z0.glb.clouddn.com/tcp.jpg" alt=""></p><p>注：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">TIME_WAIT作用在于防止TCP client的ack丢失。</div><div class="line">TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。</div><div class="line">TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。</div><div class="line">等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</div></pre></td></tr></table></figure><p></p><h2 id="什么是MIME"><a href="#什么是MIME" class="headerlink" title="什么是MIME"></a>什么是MIME</h2><p>用于标记传输的数据的文件类型。<br>最早应用于电子邮件系统，但后来也应用到浏览器，以及所有的cs 交互模型中。在HTTP协议中用Content-type描述。<br>MIME(Multipurpose Internet Mail Extensions)<br>多用途互联网邮件扩展类型，是一个互联网标准，标准定义在 <a href="http://www.cnpaf.net/class/rfcall/" target="_blank" rel="external">RFC</a> 文档中。<br>http post提交表单格式数据 content-type ：application/x-www-form-urlencoded<br>http post提交json格式数据 content-type ：application/json</p><hr><h1 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>UDP: User Datagram Protocol 用户数据报协议 是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。<a href="http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/" target="_blank" rel="external">参考</a> <a href="https://github.com/netty/netty/tree/4.0/example/src/main/java/io/netty/example/qotm" target="_blank" rel="external">Netty UDP 官方 demo</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在选择使用协议的时候，选择UDP必须要谨慎。在网络质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。但是由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多。<br>UDP广播：广播使用广播地址255.255.255.255，将消息发送到在同一广播网络上的每个主机。值得强调的是：本地广播信息是不会被路由器转发。当然这是十分容易理解的，因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么IP协议的设计者故意没有定义互联网范围的广播机制。其实广播顾名思义，就是想局域网内所有的人说话，但是广播还是要指明接收者的端口号的，因为不可能接受者的所有端口都来收听广播。</p><h2 id="UDP广播"><a href="#UDP广播" class="headerlink" title="UDP广播"></a>UDP广播</h2><p>广播使用广播地址255.255.255.255，将消息发送到在同一广播网络上的每个主机。值得强调的是：本地广播信息是不会被路由器转发。当然这是十分容易理解的，因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么IP协议的设计者故意没有定义互联网范围的广播机制。其实广播顾名思义，就是想局域网内所有的人说话，但是广播还是要指明接收者的端口号的，因为不可能接受者的所有端口都来收听广播。</p><h3 id="发送接收代码"><a href="#发送接收代码" class="headerlink" title="发送接收代码"></a>发送接收代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public static void sendBroadcast(byte[] data, int port) throws Exception&#123;</div><div class="line">    DatagramSocket socket = new DatagramSocket();</div><div class="line">    socket.setBroadcast(true);</div><div class="line">    DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(&quot;255.255.255.255&quot;), port);</div><div class="line">    socket.send(packet);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void receiveBoradcast(int port) &#123;</div><div class="line">    new Thread(new Runnable() &#123;</div><div class="line"></div><div class="line">        DatagramSocket socket;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            while (true) &#123;</div><div class="line">                try &#123;</div><div class="line">                    receive(port);</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void receive(int port) throws Exception&#123;</div><div class="line">            if (socket == null || socket.isClosed()) &#123;</div><div class="line">                socket = new DatagramSocket(port);</div><div class="line">                socket.setBroadcast(true);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            byte[] buffer = new byte[1024 * 100];</div><div class="line">            DatagramPacket packet = new DatagramPacket(buffer , buffer.length);</div><div class="line">            socket.receive(packet);</div><div class="line">            String data = new String(packet.getData(), 0, packet.getLength());</div><div class="line">            Log.i(&quot;receiver&quot;, data);</div><div class="line">            socket.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Netty-实现代码"><a href="#Netty-实现代码" class="headerlink" title="Netty 实现代码"></a>Netty 实现代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public class Broadcast &#123;</div><div class="line"></div><div class="line">    Channel udpChannel;</div><div class="line"></div><div class="line">    public void send(String data) throws Exception&#123;</div><div class="line">        if(udpChannel != null) &#123;</div><div class="line">            udpChannel.writeAndFlush(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void init(int port) &#123;</div><div class="line">        NioEventLoopGroup group = new NioEventLoopGroup();</div><div class="line">        Bootstrap bootstrap = new Bootstrap();</div><div class="line">        bootstrap.group(group)</div><div class="line">                .channel(NioDatagramChannel.class)</div><div class="line">                .option(ChannelOption.SO_BROADCAST, true)</div><div class="line">                .handler(new MessageToMessageEncoder&lt;String&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    protected void encode(ChannelHandlerContext ctx, String msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class="line">                        InetSocketAddress remoteAddress = new InetSocketAddress(&quot;255.255.255.255&quot;, port);</div><div class="line">                        out.add(new DatagramPacket(Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8), remoteAddress));</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">        udpChannel = bootstrap.bind(0).syncUninterruptibly().channel();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public class BroadcastReceiver &#123;</div><div class="line"></div><div class="line">    public void start(int port)&#123;</div><div class="line">        Bootstrap b = new Bootstrap();</div><div class="line">        NioEventLoopGroup group = new NioEventLoopGroup();</div><div class="line">        try &#123;</div><div class="line">            b.group(group)</div><div class="line">                    .channel(NioDatagramChannel.class)</div><div class="line">                    .option(ChannelOption.SO_BROADCAST, true)</div><div class="line">                    .handler(new SimpleChannelInboundHandler&lt;DatagramPacket&gt;() &#123;</div><div class="line"></div><div class="line">                        @Override</div><div class="line">                        protected void messageReceived(ChannelHandlerContext ctx, DatagramPacket packet) throws Exception &#123;</div><div class="line">                            String req = packet.content().toString(CharsetUtil.UTF_8);</div><div class="line">                            System.out.println(req);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            b.bind(port).sync().channel().closeFuture().await();</div><div class="line">        &#125;catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;finally &#123;</div><div class="line">            group.shutdownGracefully();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="UDP多播"><a href="#UDP多播" class="headerlink" title="UDP多播"></a>UDP多播</h2><p>多播数据报套接字类用于发送和接收 IP 多播包。MulticastSocket 是一种 (UDP) DatagramSocket，它具有加入 Internet 上其他多播主机的“组”的附加功能。<br>多播组通过 D 类 IP 地址和标准 UDP 端口号指定。D 类 IP 地址在 224.0.0.0 和 239.255.255.255 的范围内（包括两者）。地址 224.0.0.0 被保留，不应使用。</p><h3 id="多播代码"><a href="#多播代码" class="headerlink" title="多播代码"></a>多播代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class MultiBroadcast &#123;</div><div class="line"></div><div class="line">    public void startReveive(String host, int port) &#123;</div><div class="line"></div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line"></div><div class="line">            MulticastSocket ms;</div><div class="line"></div><div class="line">            private void receive(String host, int port) throws Exception&#123;</div><div class="line">                byte[] buf = new byte[1024 * 100];</div><div class="line">                if(ms == null || ms.isClosed()) &#123;</div><div class="line">                    ms = new MulticastSocket(port);</div><div class="line">                    DatagramPacket dp = new DatagramPacket(buf, buf.length);</div><div class="line">                    InetAddress group = InetAddress.getByName(host);</div><div class="line">                    ms.joinGroup(group);</div><div class="line">                    ms.receive(dp);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Log.i(&quot;receiver&quot;, new String(buf));</div><div class="line">                ms.close();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                while (true) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        receive(host, port);</div><div class="line">                        Thread.sleep(100);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void send(String host, int port, String message) throws Exception&#123;</div><div class="line">        InetAddress group = InetAddress.getByName(host);</div><div class="line">        MulticastSocket s = new MulticastSocket();</div><div class="line">        s.joinGroup(group);</div><div class="line">        DatagramPacket dp = new DatagramPacket(message.getBytes(),message.length(), group,port);</div><div class="line">        s.send(dp);</div><div class="line">        s.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="UDP单播"><a href="#UDP单播" class="headerlink" title="UDP单播"></a>UDP单播</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public class UnicastBroadcast &#123;</div><div class="line"></div><div class="line">    public void send(String host, int port, byte[] message) throws Exception&#123;</div><div class="line">        //sending data to host and its port</div><div class="line">        InetAddress address = InetAddress.getByName(host);</div><div class="line">        // Initialize a datagram packet with data and address</div><div class="line">        DatagramPacket packet = new DatagramPacket(message, message.length, address, port);</div><div class="line">        // Create a datagram socket, send the packet through it, close it.</div><div class="line">        DatagramSocket dsocket = new DatagramSocket();</div><div class="line">        dsocket.send(packet);</div><div class="line">        dsocket.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startReceive() &#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line"></div><div class="line">            DatagramSocket dsocket;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            private void receive(int port) throws Exception&#123;</div><div class="line"></div><div class="line">                byte[] buffer = new byte[2048];</div><div class="line">                if(dsocket == null || dsocket.isClosed()) &#123;</div><div class="line">                    //receiving data from its port</div><div class="line">                    dsocket = new DatagramSocket(port);</div><div class="line">                    // Create a buffer to read datagrams into. If a</div><div class="line">                    // packet is larger than this buffer, the</div><div class="line">                    // excess will simply be discarded!</div><div class="line"></div><div class="line">                    // Create a packet to receive data into the buffer</div><div class="line">                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);</div><div class="line"></div><div class="line">                    // Wait to receive a datagram</div><div class="line">                    dsocket.receive(packet);</div><div class="line">                    // Convert the contents to a string, and display them</div><div class="line">                    String msg = new String(buffer);</div><div class="line">                    System.out.println(packet.getAddress().getHostName() + &quot;: &quot; + msg);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                dsocket.close();</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="url编码问题"><a href="#url编码问题" class="headerlink" title="url编码问题"></a>url编码问题</h1><p>url 标准为美国制定，只支持asc编码，所以</p><ol><li>get 请求等需要传递汉子等非asc编码支持的字符时，违背的这个标准，需要url encode</li><li>参数包含&amp; = 等这些标准连接的特殊符号时，也需要url encode</li></ol><h1 id="http（android-api）"><a href="#http（android-api）" class="headerlink" title="http（android api）"></a>http（android api）</h1><p>HttpURLConnection <a href="http://stackoverflow.com/questions/2793150/using-java-net-urlconnection-to-fire-and-handle-http-requests/2793153#2793153" target="_blank" rel="external">代码demo</a></p><h2 id="发送："><a href="#发送：" class="headerlink" title="发送："></a>发送：</h2><h3 id="1-设置协议："><a href="#1-设置协议：" class="headerlink" title="1.设置协议："></a>1.设置协议：</h3><p>con.setRequestMethod(“post”), timeout 等。</p><h3 id="2-发送内容："><a href="#2-发送内容：" class="headerlink" title="2.发送内容："></a>2.发送内容：</h3><p>os = con.getOutPutStream()。<br>os.writeBytes(json data 数据).toString()</p><h3 id="3-发送流结构："><a href="#3-发送流结构：" class="headerlink" title="3.发送流结构："></a>3.发送流结构：</h3><p>请求行（自动）<br>消息头（协议）<br>内容（数据）</p><h2 id="接收："><a href="#接收：" class="headerlink" title="接收："></a>接收：</h2><p>1.con.getInputStream();<br>read();<br>2.接收流结构<br>状态行（状态码）<br>消息头（协议）<br>内容（数据）</p><blockquote><p>注：https<br>在上面的设置协议中加入：</p><ol><li>setHostnameVerifier( );<br>2.构造器中加入 setDefaultSSLSocketFactory</li></ol></blockquote><h1 id="http（apache-api）"><a href="#http（apache-api）" class="headerlink" title="http（apache api）"></a>http（apache api）</h1><h2 id="post发送："><a href="#post发送：" class="headerlink" title="post发送："></a>post发送：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.pos = new HttpPost（url）</div><div class="line">2.pos.setHeader()   协议</div><div class="line">3.pos.setEntity（） json数据</div><div class="line">4.re = new HttpClient（）.execute（pos）</div><div class="line">5.EntityUtils.toString(re.getEntity（）)</div></pre></td></tr></table></figure><h2 id="get发送："><a href="#get发送：" class="headerlink" title="get发送："></a>get发送：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.get = new HttpGet（url）</div><div class="line">2.get.setHeader()</div><div class="line">3.re = new HttpClient().execute(get)</div><div class="line">4. status = re.getStatusline().getStatusCode()</div><div class="line">re.getEntity().getContent().</div></pre></td></tr></table></figure><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p><img src="http://7xoxmg.com1.z0.glb.clouddn.com/ssl_handshake_rsa.jpg" alt=""></p></div><div></div><div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/02/10/命令行/" rel="next" title="命令行"><i class="fa fa-chevron-left"></i> 命令行</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/02/11/框架/" rel="prev" title="框架">框架 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div></div><div class="ds-thread" data-thread-key="<%- page.path %>" data-title="<%- page.title %>" data-url="<%- page.permalink %>"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://7xoxmg.com1.z0.glb.clouddn.com/avatar.jpg" alt="peter"><p class="site-author-name" itemprop="name">peter</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/javalive09" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="http://stackoverflow.com/users/4674672/peter-zhang" target="_blank" title="Stack Overflow"><i class="fa fa-fw fa-stack-overflow"></i> Stack Overflow </a></span><span class="links-of-author-item"><a href="/about" target="_blank" title="工具网站"><i class="fa fa-fw fa-globe"></i> 工具网站</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#URI（uniformresource-identifier）和URL（universal-resource-Loactor）的区别"><span class="nav-number">1.</span> <span class="nav-text">URI（uniformresource identifier）和URL（universal resource Loactor）的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP协议"><span class="nav-number">2.</span> <span class="nav-text">HTTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#请求"><span class="nav-number">2.1.</span> <span class="nav-text">请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#响应"><span class="nav-number">2.2.</span> <span class="nav-text">响应</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#状态码"><span class="nav-number">2.2.1.</span> <span class="nav-text">状态码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-header-fileds"><span class="nav-number">2.3.</span> <span class="nav-text">http header fileds</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#General-Header-Fields"><span class="nav-number">2.3.1.</span> <span class="nav-text">General Header Fields</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request-Header-Fields"><span class="nav-number">2.3.2.</span> <span class="nav-text">Request Header Fields</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Response-Header-Fields"><span class="nav-number">2.3.3.</span> <span class="nav-text">Response Header Fields</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Entity-Header-Fields"><span class="nav-number">2.3.4.</span> <span class="nav-text">Entity Header Fields</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other-Header-Fields"><span class="nav-number">2.3.5.</span> <span class="nav-text">other Header Fields</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OSI网络模型"><span class="nav-number">3.</span> <span class="nav-text">OSI网络模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp连接-为什么要进行3次握手，断开为什么要4次握手"><span class="nav-number">4.</span> <span class="nav-text">tcp连接 为什么要进行3次握手，断开为什么要4次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#建立连接"><span class="nav-number">4.1.</span> <span class="nav-text">建立连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#断开连接"><span class="nav-number">4.1.1.</span> <span class="nav-text">断开连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是MIME"><span class="nav-number">4.2.</span> <span class="nav-text">什么是MIME</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UDP协议"><span class="nav-number">5.</span> <span class="nav-text">UDP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用"><span class="nav-number">5.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP广播"><span class="nav-number">5.3.</span> <span class="nav-text">UDP广播</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发送接收代码"><span class="nav-number">5.3.1.</span> <span class="nav-text">发送接收代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty-实现代码"><span class="nav-number">5.3.2.</span> <span class="nav-text">Netty 实现代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP多播"><span class="nav-number">5.4.</span> <span class="nav-text">UDP多播</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多播代码"><span class="nav-number">5.4.1.</span> <span class="nav-text">多播代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP单播"><span class="nav-number">5.5.</span> <span class="nav-text">UDP单播</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#url编码问题"><span class="nav-number">6.</span> <span class="nav-text">url编码问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http（android-api）"><span class="nav-number">7.</span> <span class="nav-text">http（android api）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#发送："><span class="nav-number">7.1.</span> <span class="nav-text">发送：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-设置协议："><span class="nav-number">7.1.1.</span> <span class="nav-text">1.设置协议：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-发送内容："><span class="nav-number">7.1.2.</span> <span class="nav-text">2.发送内容：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-发送流结构："><span class="nav-number">7.1.3.</span> <span class="nav-text">3.发送流结构：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接收："><span class="nav-number">7.2.</span> <span class="nav-text">接收：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http（apache-api）"><span class="nav-number">8.</span> <span class="nav-text">http（apache api）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#post发送："><span class="nav-number">8.1.</span> <span class="nav-text">post发送：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get发送："><span class="nav-number">8.2.</span> <span class="nav-text">get发送：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#https"><span class="nav-number">9.</span> <span class="nav-text">https</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">peter</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script>var cloudTieConfig={url:document.location.href,sourceId:"",productKey:"a44a85017991439782ca46cd64b41841",target:"cloud-tie-wrapper"}</script><script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script></body></html>