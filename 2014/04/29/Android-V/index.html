<!doctype html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="viewanimation帧动画 frame anim动画类 AnimationDrawable配置xml文件 animation-listanimation自定义 重写方法applyTransformation()改变Transformation启动 setBackground()补间动画 tween anim动画类 AlphaAnimation , RotateAnimation, Scale"><meta property="og:type" content="article"><meta property="og:title" content="Android-V"><meta property="og:url" content="http://yoursite.com/2014/04/29/Android-V/index.html"><meta property="og:site_name" content="200code"><meta property="og:description" content="viewanimation帧动画 frame anim动画类 AnimationDrawable配置xml文件 animation-listanimation自定义 重写方法applyTransformation()改变Transformation启动 setBackground()补间动画 tween anim动画类 AlphaAnimation , RotateAnimation, Scale"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://yoursite.com/images/pixel.jpg"><meta property="og:image" content="http://yoursite.com/images/scroll.png"><meta property="og:image" content="http://yoursite.com/images/fitres.jpeg"><meta property="og:image" content="http://yoursite.com/images/screen_refresh.jpg"><meta property="og:image" content="http://yoursite.com/images/one_buffer.jpg"><meta property="og:image" content="http://yoursite.com/images/double_buffer.jpg"><meta property="og:image" content="http://yoursite.com/images/double_buffer_jank.jpg"><meta property="og:image" content="http://yoursite.com/images/triple_buffer_jank.jpg"><meta property="og:image" content="http://yoursite.com/images/triple_buffer.jpg"><meta property="og:updated_time" content="2019-11-14T12:39:17.096Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Android-V"><meta name="twitter:description" content="viewanimation帧动画 frame anim动画类 AnimationDrawable配置xml文件 animation-listanimation自定义 重写方法applyTransformation()改变Transformation启动 setBackground()补间动画 tween anim动画类 AlphaAnimation , RotateAnimation, Scale"><meta name="twitter:image" content="http://yoursite.com/images/pixel.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"always"},fancybox:!1,motion:!1,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2014/04/29/Android-V/"><title>Android-V | 200code</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?afd325d3333e718fc607b569c45d57a4";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">200code</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/04/29/Android-V/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="peter"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="200code"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="200code" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Android-V</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-04-29T18:47:23+08:00">2014-04-29</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="view"><a href="#view" class="headerlink" title="view"></a>view</h1><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><h3 id="帧动画-frame-anim"><a href="#帧动画-frame-anim" class="headerlink" title="帧动画 frame anim"></a>帧动画 frame anim</h3><p>动画类 AnimationDrawable<br>配置xml文件 animation-list<br>animation自定义 重写方法applyTransformation()改变Transformation<br>启动 setBackground()</p><h3 id="补间动画-tween-anim"><a href="#补间动画-tween-anim" class="headerlink" title="补间动画 tween anim"></a>补间动画 tween anim</h3><p>动画类 AlphaAnimation , RotateAnimation, ScaleAnimation, TranslateAnimation<br>配置xml文件 alpha, rotate, scale, translate<br>启动 AnimationUtils.loadAnimation（context，R.anim.x）;</p><h4 id="alpha"><a href="#alpha" class="headerlink" title="alpha"></a>alpha</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;&gt;  </div><div class="line">    &lt;!-- fromAlpha和toAlpha是起始透明度和结束时透明度 --&gt;  </div><div class="line">    &lt;alpha  </div><div class="line">        android:fromAlpha=&quot;1.0&quot;  </div><div class="line">        android:toAlpha=&quot;0.0&quot;  </div><div class="line">        android:startOffset=&quot;500&quot;  </div><div class="line">        android:duration=&quot;500&quot;/&gt;  </div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure><h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;&gt;  </div><div class="line">    &lt;!--  </div><div class="line">        fromDegrees:开始的角度  </div><div class="line">        toDegrees：结束的角度，+表示是正的  </div><div class="line">        当角度为负数——表示逆时针旋转  </div><div class="line">        当角度为正数——表示顺时针旋转  </div><div class="line">        pivotX：用于设置旋转时的x轴坐标  </div><div class="line">        例  </div><div class="line">           1)当值为&quot;50&quot;，表示使用绝对位置定位  </div><div class="line">           2)当值为&quot;50%&quot;，表示使用相对于控件本身定位  </div><div class="line">           3)当值为&quot;50%p&quot;，表示使用相对于控件的父控件定位  </div><div class="line">        pivotY：用于设置旋转时的y轴坐标  </div><div class="line">      --&gt;  </div><div class="line">    &lt;rotate  </div><div class="line">        android:fromDegrees=&quot;0&quot;  </div><div class="line">        android:toDegrees=&quot;+360&quot;  </div><div class="line">        android:pivotX=&quot;50%&quot;  </div><div class="line">        android:pivotY=&quot;50%&quot;  </div><div class="line">        android:duration=&quot;1000&quot;/&gt;  </div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;&gt;  </div><div class="line">   &lt;!--  </div><div class="line">       起始x轴坐标  </div><div class="line">           止x轴坐标  </div><div class="line">           始y轴坐标  </div><div class="line">           止y轴坐标  </div><div class="line">           轴的坐标  </div><div class="line">           轴的坐标  </div><div class="line">     --&gt;  </div><div class="line">   &lt;scale  </div><div class="line">       android:fromXScale=&quot;1.0&quot;  </div><div class="line">       android:toXScale=&quot;0.0&quot;  </div><div class="line">       android:fromYScale=&quot;1.0&quot;  </div><div class="line">       android:toYScale=&quot;0.0&quot;  </div><div class="line">       android:pivotX=&quot;50%&quot;  </div><div class="line">       android:pivotY=&quot;50%&quot;  </div><div class="line">       android:duration=&quot;1000&quot;/&gt;  </div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure><h4 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;&gt;  </div><div class="line">    &lt;!--  </div><div class="line">           始x轴坐标  </div><div class="line">           止x轴坐标  </div><div class="line">           始y轴坐标  </div><div class="line">           止y轴坐标  </div><div class="line">      --&gt;  </div><div class="line">    &lt;translate  </div><div class="line">        android:fromXDelta=&quot;0%&quot;  </div><div class="line">        android:toXDelta=&quot;100%&quot;  </div><div class="line">        android:fromYDelta=&quot;0%&quot;  </div><div class="line">        android:toYDelta=&quot;100%&quot;  </div><div class="line">        android:duration=&quot;2000&quot;/&gt;  </div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure><h3 id="属性动画-property-anim"><a href="#属性动画-property-anim" class="headerlink" title="属性动画 property anim"></a>属性动画 property anim</h3><p><a href="https://github.com/JakeWharton/NineOldAndroids/tree/master/sample/src/com/jakewharton/nineoldandroids/sample" target="_blank" rel="noopener">nineoldandroids sample</a><br>动画类 valueAnimator，objectAnimator<br>配置xml文件 alpha, rotate, scale, translate<br>启动 AnimatorInflater.loadAnimator(context, R.anim.x);</p><h4 id="valueAnimator"><a href="#valueAnimator" class="headerlink" title="valueAnimator"></a>valueAnimator</h4><p>addupdateListener() { 属性改变 }</p><h4 id="objectAnimator"><a href="#objectAnimator" class="headerlink" title="objectAnimator"></a>objectAnimator</h4><p>属性 xxx<br>setX() , getX()<br>_offx 实例化</p><h4 id="offint-offfloat-offobject-offproperty-propertyvalueHolder-setCurrentPlayTime-long-playTime"><a href="#offint-offfloat-offobject-offproperty-propertyvalueHolder-setCurrentPlayTime-long-playTime" class="headerlink" title="offint , offfloat, offobject, offproperty , propertyvalueHolder, setCurrentPlayTime(long playTime)"></a>offint , offfloat, offobject, offproperty , propertyvalueHolder, setCurrentPlayTime(long playTime)</h4><h3 id="interpolator"><a href="#interpolator" class="headerlink" title="interpolator"></a>interpolator</h3><p>差值器，控制动画的变化频率 （ ～0 —- ～1）相当于加速度 a 。<br>根据系统 SystemClock.uptimeMillis()（每次调用都获取）<br>1 计算出在(0 ~ duration ) 哪个时间点<br>2 再计算出normalizedTime （0 ～ 1）百分比<br>3 input 为 normalizedTime（0～ 1）<br>4 input 为 delta time ／ duration (0 ~ 1)<br>5 getInterpolation(float input)。<br>帧动画 补间动画 android.view.animation.Interpolator在view包下<br>属性动画 android.animation.TimeInterpolator 在animation包下<br>4.0 之后 Interpolator 继承自TimeInterpolator<br><a href="http://yifeng.studio/2017/06/23/android-animation-interpolators/" target="_blank" rel="noopener">从数学公式入手，详细了解 Animation 的 Interpolators</a></p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>animation中通过applyTransformation() 来改变transformation 来作动画</p><h3 id="帧数"><a href="#帧数" class="headerlink" title="帧数"></a>帧数</h3><p>游戏一般到60 帧才流畅。 animator 睡眠时间是10ms 即100帧每秒。这个帧数可以调节静态方法ValueAnimator.setFrameDelay(long frameDelay)。</p><h3 id="TypeEvaluator"><a href="#TypeEvaluator" class="headerlink" title="TypeEvaluator"></a>TypeEvaluator</h3><p>控制做动画的view的位置。<br>根据Interpolator 计算出的fraction 和初始 、结束值来计算view 的属性值。<br>默认是 IntEvaluator 和 FloatEvaluator</p><h2 id="view-重绘的时机"><a href="#view-重绘的时机" class="headerlink" title="view 重绘的时机"></a>view 重绘的时机</h2><h3 id="主动重绘"><a href="#主动重绘" class="headerlink" title="主动重绘"></a>主动重绘</h3><p>invalidate()；<br>postinvalidate()；</p><h3 id="被动重绘"><a href="#被动重绘" class="headerlink" title="被动重绘"></a>被动重绘</h3><p>被动重绘的原则: view变化就会重绘</p><h4 id="view状态变化"><a href="#view状态变化" class="headerlink" title="view状态变化"></a>view状态变化</h4><p>focus<br>enable<br>selected<br>press<br>visiable</p><h4 id="view结构变化"><a href="#view结构变化" class="headerlink" title="view结构变化"></a>view结构变化</h4><p>增减 子view<br>宽高大小变化</p><h2 id="view绘制过程"><a href="#view绘制过程" class="headerlink" title="view绘制过程"></a>view绘制过程</h2><p>viewroot 发异步消息, 由Decorview开始</p><h3 id="1-measure-确定大小"><a href="#1-measure-确定大小" class="headerlink" title="1.measure 确定大小"></a>1.measure 确定大小</h3><p>onmeasure（）可以改变measure大小<br>setMeasureDimension（）设置大小</p><h3 id="2-layout-确定位置"><a href="#2-layout-确定位置" class="headerlink" title="2.layout 确定位置"></a>2.layout 确定位置</h3><p>onlayout（）可以改变view位置<br>setFrame（）设置（t，l，r，b）值</p><h3 id="3-draw-绘制"><a href="#3-draw-绘制" class="headerlink" title="3.draw 绘制"></a>3.draw 绘制</h3><ul><li>画背景</li><li>ondraw（）绘制视图本身</li><li>dispatchDraw（）绘制子视图</li><li>ondrawScrollBar（）绘滚动条<h3 id="invalidated调用时机"><a href="#invalidated调用时机" class="headerlink" title="invalidated调用时机"></a>invalidated调用时机</h3>重draw调用 3<h3 id="requestlayout调用时机"><a href="#requestlayout调用时机" class="headerlink" title="requestlayout调用时机"></a>requestlayout调用时机</h3>重新measure调用 1，layout调用 2</li></ul><h2 id="View-invalidate方法研究"><a href="#View-invalidate方法研究" class="headerlink" title="View invalidate方法研究"></a>View invalidate方法研究</h2><p>Invalidate 英文废弃，无效的意思。不知道写api的人为什么不用redraw之类的更直接的词语而用这个词语。<br>大家都知道，view 调用 Invalidate 方法会导致重绘。<br>那么具体的情况是什么呢？<br>我写了一个demo去研究这个方法的作用。<a href="http://download.csdn.net/detail/javalive09/6867681" target="_blank" rel="noopener">下载</a><br>在VISIBLE的情况下：</p><h3 id="一个非容器类的view-调用Invalidate"><a href="#一个非容器类的view-调用Invalidate" class="headerlink" title="一个非容器类的view 调用Invalidate():"></a>一个非容器类的view 调用Invalidate():</h3><p>会调用 此view的onDraw() ,重绘它自己。</p><h3 id="一个容器类的view调用Invalidate"><a href="#一个容器类的view调用Invalidate" class="headerlink" title="一个容器类的view调用Invalidate():"></a>一个容器类的view调用Invalidate():</h3><p>如果这个容器有背景，会调用 此view的onDraw() ,重绘它自己。<br>如果这个容器没有背景，不会调用 此view的onDraw() ,重绘它自己。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>不是调用Invalidate()就一定会导致重绘。</p><h2 id="addView-源码调用顺序的迷惑"><a href="#addView-源码调用顺序的迷惑" class="headerlink" title="addView 源码调用顺序的迷惑"></a>addView 源码调用顺序的迷惑</h2><p>addView 源码中方法调用顺序的迷惑<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void addView(View child,int index, LayoutParams params) &#123;  </div><div class="line">        if (DBG) &#123;  </div><div class="line">            System.out.println(this +&quot; addView&quot;);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        // addViewInner() will call child.requestLayout() when setting the new LayoutParams  </div><div class="line">        // therefore, we call requestLayout() on ourselves before, so that the child&apos;s request  </div><div class="line">        // will be blocked at our level  </div><div class="line">        requestLayout();  </div><div class="line">        invalidate(true);  </div><div class="line">        addViewInner(child, index, params, false);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure><p></p><p>为什么在addViewInner(); 前要使用requestLayout(); addViewInner里面会调用requestLayout(); 这样逻辑上是不是重复了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void requestLayout() &#123;  </div><div class="line">    mPrivateFlags |= FORCE_LAYOUT;  </div><div class="line">    mPrivateFlags |= INVALIDATED;  </div><div class="line">  </div><div class="line">    if (mLayoutParams != null) &#123;  </div><div class="line">        mLayoutParams.onResolveLayoutDirection(getResolvedLayoutDirection());  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;  </div><div class="line">        mParent.requestLayout();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>requestLayout();的很重要的一步操作是给mPrivateFlags赋上FORCE_LAYOUT值。<br>if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) 这一步逻辑是。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isLayoutRequested() &#123;  </div><div class="line">    return (mPrivateFlags &amp; FORCE_LAYOUT) == FORCE_LAYOUT;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>由于requestLayout() 是从当前view往上传递来申请重新layout布局。如果父容器的mPrivateFlags不包含FORCE_LAYOUT。执行父容器的requestLayout();<br>这里父容器mPrivateFlags包含FORCE_LAYOUT，所以不会向上传递申请重新layout布局。<br>那么 mPrivateFlags 什么时候清空FORCE_LAYOUT值呢？在view 的layout 方法最后：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;  </div><div class="line">    int oldL = mLeft;  </div><div class="line">    int oldT = mTop;  </div><div class="line">    int oldB = mBottom;  </div><div class="line">    int oldR = mRight;  </div><div class="line">    boolean changed = setFrame(l, t, r, b);  </div><div class="line">    if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;  </div><div class="line">        onLayout(changed, l, t, r, b);  </div><div class="line">        mPrivateFlags &amp;= ~LAYOUT_REQUIRED;  </div><div class="line">  </div><div class="line">        ListenerInfo li = mListenerInfo;  </div><div class="line">        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;  </div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =  </div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();  </div><div class="line">            int numListeners = listenersCopy.size();  </div><div class="line">            for (int i = 0; i &lt; numListeners; ++i) &#123;  </div><div class="line">                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    mPrivateFlags &amp;= ~FORCE_LAYOUT;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>mPrivateFlags &amp;= ~FORCE_LAYOUT 清空了FORCE_LAYOUT。也就是 这个view layout 之后 FORCE_LAYOUT会被清空。</p><p>例子代码<a href="http://download.csdn.net/detail/javalive09/6867681" target="_blank" rel="noopener">下载</a><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vg.addView(new Son(MainActivity.this));  </div><div class="line">vg.addView(new Son(MainActivity.this));  </div><div class="line">vg.addView(new Son(MainActivity.this));</div></pre></td></tr></table></figure><p></p><p>站在父容器vg 的角度看，会引发如下流程：</p><p>view1:</p><ol><li>requestLayout(); //发出layout消息, 触发vg 的 onMeasure(), onLayout()</li><li>invalidate(true); //发出重绘制消息，触发vg 的draw()</li><li>child.setLayoutParams(params); //会触发child的layout(), 不会向父容器方向传递触发vg的layout。<br>因为被步骤1的父容器layout 的 mPrivateFlags == FORCE_LAYOUT阻断。</li></ol><p>view2:</p><ol><li>requestLayout(); // 不会发出layout消息，不会触发vg 的 onMeasure(), onLayout()。<br>因为被步骤1的父容器layout 的 mPrivateFlags == FORCE_LAYOUT阻断。</li><li>invalidate(true); //不会发出重绘消息，不会触发vg 的draw()。<br>因为被步骤2的 mPrivateFlags DRAWN ／ DRAWING_CACHE_VALID／INVALIDATED阻断。</li><li>child.setLayoutParams(params); //会触发child的layout(), 不会向父容器方向传递触发vg的layout。<br>因为被步骤1的父容器layout 的 mPrivateFlags == FORCE_LAYOUT阻断。</li></ol><p>view3:</p><ol><li>requestLayout(); // 不会发出layout消息，不会触发vg 的 onMeasure(), onLayout()。<br>因为被步骤1的父容器layout 的 mPrivateFlags == FORCE_LAYOUT阻断。</li><li>invalidate(true); //不会发出重绘消息，不会触发vg 的draw()。<br>因为被步骤2的 mPrivateFlags DRAWN ／ DRAWING_CACHE_VALID／INVALIDATED阻断。</li><li>child.setLayoutParams(params); //会触发child的layout(), 不会向父容器方向传递触发vg的layout。<br>被步骤1的父容器layout 的 mPrivateFlags == FORCE_LAYOUT阻断。<br>所以父类容器以及子view 的 onMeasure(), onLayout() 都只会被各调用一次。</li></ol><h2 id="view-的OnTouchListener和OnClickListener的区别"><a href="#view-的OnTouchListener和OnClickListener的区别" class="headerlink" title="view 的OnTouchListener和OnClickListener的区别"></a>view 的OnTouchListener和OnClickListener的区别</h2><p>有时候会迷惑，OnTouchListener和OnClickListener究竟有什么区别。 通过源码分析一下。</p><h3 id="OnTouchListener的触发逻辑"><a href="#OnTouchListener的触发逻辑" class="headerlink" title="OnTouchListener的触发逻辑"></a>OnTouchListener的触发逻辑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;  </div><div class="line">    if (mInputEventConsistencyVerifier != null) &#123;  </div><div class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, 0);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    if (onFilterTouchEventForSecurity(event)) &#123;  </div><div class="line">        //noinspection SimplifiableIfStatement  </div><div class="line">        ListenerInfo li = mListenerInfo;  </div><div class="line">        if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED  </div><div class="line">                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;  </div><div class="line">            return true;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        if (onTouchEvent(event)) &#123;  </div><div class="line">            return true;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    if (mInputEventConsistencyVerifier != null) &#123;  </div><div class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);  </div><div class="line">    &#125;  </div><div class="line">    return false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>分发touch事件时 先判断mOnTouchListener.onTouch() 是否处理了 事件，如果方法返回true(处理了)，则不向下传递。<br>所以OnTouchListener 的触发时机是：手指一触摸就会触发。 action_down的时候就会触发。而且touchListener的字面意思”触碰监听”也比较贴切 。</p><h3 id="OnClickListener的触发逻辑"><a href="#OnClickListener的触发逻辑" class="headerlink" title="OnClickListener的触发逻辑"></a>OnClickListener的触发逻辑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public boolean onTouchEvent(MotionEvent event) &#123;  </div><div class="line">...  </div><div class="line">if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </div><div class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;  </div><div class="line">            switch (event.getAction()) &#123;  </div><div class="line">                case MotionEvent.ACTION_UP:  </div><div class="line">                    boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  </div><div class="line">                    if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123;  </div><div class="line">                        // take focus if we don&apos;t have it already and we should in  </div><div class="line">                        // touch mode.  </div><div class="line">                        boolean focusTaken = false;  </div><div class="line">                        if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;  </div><div class="line">                            focusTaken = requestFocus();  </div><div class="line">                        &#125;  </div><div class="line">  </div><div class="line">                        if (prepressed) &#123;  </div><div class="line">                            // The button is being released before we actually  </div><div class="line">                            // showed it as pressed.  Make it show the pressed  </div><div class="line">                            // state now (before scheduling the click) to ensure  </div><div class="line">                            // the user sees it.  </div><div class="line">                            setPressed(true);  </div><div class="line">                       &#125;  </div><div class="line">  </div><div class="line">                        if (!mHasPerformedLongPress) &#123;  </div><div class="line">                            // This is a tap, so remove the longpress check  </div><div class="line">                            removeLongPressCallback();  </div><div class="line">  </div><div class="line">                            // Only perform take click actions if we were in the pressed state  </div><div class="line">                            if (!focusTaken) &#123;  </div><div class="line">                                // Use a Runnable and post this rather than calling  </div><div class="line">                                // performClick directly. This lets other visual state  </div><div class="line">                                // of the view update before click actions start.  </div><div class="line">                                if (mPerformClick == null) &#123;  </div><div class="line">                                    mPerformClick = new PerformClick();  </div><div class="line">                                &#125;  </div><div class="line">                                if (!post(mPerformClick)) &#123;  </div><div class="line">                                    performClick();//触发点  </div><div class="line">                                &#125;  </div><div class="line">                            &#125;  </div><div class="line">                        &#125;  </div><div class="line">...  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面看触发点performClick()<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public boolean performClick() &#123;  </div><div class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  </div><div class="line">  </div><div class="line">    ListenerInfo li = mListenerInfo;  </div><div class="line">    if (li != null &amp;&amp; li.mOnClickListener != null) &#123;  </div><div class="line">        playSoundEffect(SoundEffectConstants.CLICK);  </div><div class="line">        li.mOnClickListener.onClick(this);//触发点击事件  </div><div class="line">        return true;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    return false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在onTouch()的事件处理的逻辑中，手指抬起 action_up 时，符合click的条件，则触发mOnClickListener的逻辑。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>OnTouchListener的触发点：action_down 手指按下时<br>OnClickListener的触发点：action_up 手指抬起时<br>OnTouchListener 处理逻辑在OnClickListener之前, 所以OnTouchListener 的onTouch（）如果返回true, 则 onTouchEvent ()中所有逻辑失效，当然OnClickListener也不会触发。</p><h2 id="View-touch的传递流程"><a href="#View-touch的传递流程" class="headerlink" title="View touch的传递流程"></a>View touch的传递流程</h2><p>1 - ViewRootImpl :deliverPointerEvent()<br>2 - PhoneWindow$DecorView :dispatchTouchEvent()<br>3 - Activity :dispatchTouchEvent()<br>4 - PhoneWindow :superDispatchTouchEvent()<br>5 - PhoneWindow$DecorView :superDispatchTouchEvent()<br>6 - ViewGroup :dispatchTouchEvent()<br>7 - ViewGroup :dispatchTransformedTouchEvent()<br>8 - ViewGroup :dispatchTouchEvent()</p><blockquote><p>a 如果该层view容器没有事件拦截 :onInterceptTouchEvent() == false</p></blockquote><p>9 - 延续第7 ～ 8步，遍历传递。<br>10 - View :dispatchTouchEvent()<br>11 - View :onTouchEvent()</p><blockquote><p>b 如果该层view容器有事件拦截 :onInterceptTouchEvent() == true</p></blockquote><p>9 - 容器view :onInterceptTouchEvent()<br>10 - ViewGroup :dispatchTransformedTouchEvent()<br>11 - View :dispatchTouchEvent()<br>12 - View :onTouchEvent()</p><h3 id="dispatchTouchEvent-调用的时机"><a href="#dispatchTouchEvent-调用的时机" class="headerlink" title="dispatchTouchEvent()调用的时机"></a>dispatchTouchEvent()调用的时机</h3><p>整个view体系保持通路的情况下，每次都调用。 只要有一层view dispatchTouchEvent返回false，短路。则之后整个view体系不会再调用此方法。</p><h3 id="onInterceptTouchEvent-调用时机"><a href="#onInterceptTouchEvent-调用时机" class="headerlink" title="onInterceptTouchEvent()调用时机"></a>onInterceptTouchEvent()调用时机</h3><p>子view requestDisallowInterceptTouchEvent(false)时:<br>整个view体系保持通路的情况下，action_down时，mFirstTouchTarget != null 时。返回true拦截了mFirstTouchTarget 会置空，则之后再也不会调用此方法。</p><h3 id="onTouchEvent-调用时机"><a href="#onTouchEvent-调用时机" class="headerlink" title="onTouchEvent()调用时机"></a>onTouchEvent()调用时机</h3><p>整个view体系保持通路的情况下，view类总会被调用。 在viewGroup容器类中：<br>a. 如果子View onTouch()返回false没处理（mFirstTouchTarget 没赋值==null），会调用本层的onTouch();<br>b. 本层拦截了事件（mFirstTouchTarget 没赋值==null）。会调用本层的onTouch();</p><blockquote><p>注： dispatchTouchEvent 返回false，则系统下次不会再调用此方法。没有传递成功，则系统认为此事件无需再处理了。<br>什么情况下 返回false:<br>1.有targetView(有childView在点中区域), targetView dispatchTouchEvent() / onTouchEvent() 返回 false；<br>2.无targetView(无childView在点中区域，或根本无childView), 当前view onTouchEvent() 返回 false; (是否clickable ，long_clickable)</p></blockquote><h2 id="View-draw方法传递流程"><a href="#View-draw方法传递流程" class="headerlink" title="View draw方法传递流程"></a>View draw方法传递流程</h2><p>1 - ViewRootImpl :doTraversal()<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void doTraversal() &#123;  </div><div class="line">    if (mTraversalScheduled) &#123;  </div><div class="line">        mTraversalScheduled = false;  </div><div class="line">        mHandler.getLooper().removeSyncBarrier(mTraversalBarrier);  </div><div class="line">  </div><div class="line">        if (mProfile) &#123;  </div><div class="line">            Debug.startMethodTracing(&quot;ViewAncestor&quot;);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;performTraversals&quot;);  </div><div class="line">        try &#123;  </div><div class="line">            performTraversals();  </div><div class="line">        &#125; finally &#123;  </div><div class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        if (mProfile) &#123;  </div><div class="line">            Debug.stopMethodTracing();  </div><div class="line">            mProfile = false;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>2 - ViewRootImpl :performTraversals()<br>3 - ViewRootImpl :performDraw()<br>4 - ViewRootImpl :draw()<br>5 - PhoneWindow$DecorView :draw()<br>6 - ViewGroup :dispatchDraw()<br>7 - ViewGroup :drawChild()<br>8 - View :draw()<br>9 - 延续第 5 ～ 8步 ，遍历绘制</p><h2 id="如何叠加多个listview-和gridview"><a href="#如何叠加多个listview-和gridview" class="headerlink" title="如何叠加多个listview 和gridview"></a>如何叠加多个listview 和gridview</h2><p>可以重写 listView的onMeasure方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;  </div><div class="line">     int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE ,    </div><div class="line">                MeasureSpec.AT_MOST);    </div><div class="line">     super.onMeasure(widthMeasureSpec, expandSpec);    </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p></p><p>listView类源码中的onMeasure方法 中<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (heightMode == MeasureSpec.AT_MOST) &#123;  </div><div class="line">    // TODO: after first layout we should maybe start at the first visible position, not 0  </div><div class="line">    heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>确定heightSize;<br>在measureHeightOfChildren方法中计算heightSize的逻辑。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (returnedHeight &gt;= maxHeight) &#123;  </div><div class="line">                // We went over, figure out which height to return.  If returnedHeight &gt; maxHeight,  </div><div class="line">                // then the i&apos;th position did not fit completely.  </div><div class="line">                return (disallowPartialChildPosition &gt;= 0) // Disallowing is enabled (&gt; -1)  </div><div class="line">                            &amp;&amp; (i &gt; disallowPartialChildPosition) // We&apos;ve past the min pos  </div><div class="line">                            &amp;&amp; (prevHeightWithoutPartialChild &gt; 0) // We have a prev height  </div><div class="line">                            &amp;&amp; (returnedHeight != maxHeight) // i&apos;th child did not fit completely  </div><div class="line">                        ? prevHeightWithoutPartialChild  </div><div class="line">                        : maxHeight;  </div><div class="line">            &#125;</div></pre></td></tr></table></figure><p></p><p>所以只要maxHeight 足够大就会用计算出来的listView的真实高度作为高。这里用的是Integer.MAX_VALUE</p><blockquote><p>注： gridView 的onMeasure（）逻辑也类似，所以也可以用这种方法。</p></blockquote><h2 id="如何获取listview的内容高度"><a href="#如何获取listview的内容高度" class="headerlink" title="如何获取listview的内容高度"></a>如何获取listview的内容高度</h2><p>有时候需要在listview 显示之前获取内容的高度。<br>可以用 item.measure(0,0); 方式计算大小再获取。</p><blockquote><p>注：<br>item.measure(); 高度的参数是wrap_content的情况下和measure（0，0）计算的高度是一样的。<br>所以简化一下，不去配 heightMeasureSpec的值了，直接用（0，0）参数。<br>如果要配的话，可以用 MeasureSpec.makeMeasureSpec(parentSize, MeasureSpec.AT_MOST)，但是显然这样比较麻烦。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int totalHeight = 0;  </div><div class="line">      for (int i = 0; i &lt; listAdapter.getCount(); i++) &#123;  </div><div class="line">         View listItem = listAdapter.getView(i, null, listView);  </div><div class="line">          listItem.measure(0, 0);//取wrap_content的大小的高  </div><div class="line">          totalHeight += listItem.getMeasuredHeight();  </div><div class="line">      &#125;</div></pre></td></tr></table></figure><h2 id="android-scrollview-滚动时会调用onlayout么"><a href="#android-scrollview-滚动时会调用onlayout么" class="headerlink" title="android scrollview 滚动时会调用onlayout么"></a>android scrollview 滚动时会调用onlayout么</h2><p>调用onlayout 的条件是 changed == true。 setFrame 返回 true 。也就是说，必须有， top，left，right，bottom 的值的变化。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;  </div><div class="line">    int oldL = mLeft;  </div><div class="line">    int oldT = mTop;  </div><div class="line">    int oldB = mBottom;  </div><div class="line">    int oldR = mRight;  </div><div class="line">    boolean changed = setFrame(l, t, r, b);  </div><div class="line">    if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;  </div><div class="line">        onLayout(changed, l, t, r, b);  </div><div class="line">        mPrivateFlags &amp;= ~LAYOUT_REQUIRED;  </div><div class="line">  </div><div class="line">        ListenerInfo li = mListenerInfo;  </div><div class="line">        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;  </div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =  </div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();  </div><div class="line">            int numListeners = listenersCopy.size();  </div><div class="line">            for (int i = 0; i &lt; numListeners; ++i) &#123;  </div><div class="line">                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    mPrivateFlags &amp;= ~FORCE_LAYOUT;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">protected boolean setFrame(int left, int top, int right, int bottom) &#123;</div><div class="line">    boolean changed = false;</div><div class="line"></div><div class="line">    if (DBG) &#123;</div><div class="line">        Log.d(&quot;View&quot;, this + &quot; View.setFrame(&quot; + left + &quot;,&quot; + top + &quot;,&quot;</div><div class="line">                + right + &quot;,&quot; + bottom + &quot;)&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</div><div class="line">        changed = true;</div><div class="line"></div><div class="line">        // Remember our drawn bit</div><div class="line">        int drawn = mPrivateFlags &amp; DRAWN;</div><div class="line"></div><div class="line">        int oldWidth = mRight - mLeft;</div><div class="line">        int oldHeight = mBottom - mTop;</div><div class="line">        int newWidth = right - left;</div><div class="line">        int newHeight = bottom - top;</div><div class="line">        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</div><div class="line"></div><div class="line">        // Invalidate our old position</div><div class="line">        invalidate(sizeChanged);</div><div class="line"></div><div class="line">        mLeft = left;</div><div class="line">        mTop = top;</div><div class="line">        mRight = right;</div><div class="line">        mBottom = bottom;</div><div class="line">        if (mDisplayList != null) &#123;</div><div class="line">            mDisplayList.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags |= HAS_BOUNDS;</div><div class="line"></div><div class="line"></div><div class="line">        if (sizeChanged) &#123;</div><div class="line">            if ((mPrivateFlags &amp; PIVOT_EXPLICITLY_SET) == 0) &#123;</div><div class="line">                // A change in dimension means an auto-centered pivot point changes, too</div><div class="line">                if (mTransformationInfo != null) &#123;</div><div class="line">                    mTransformationInfo.mMatrixDirty = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</div><div class="line">            // If we are visible, force the DRAWN bit to on so that</div><div class="line">            // this invalidate will go through (at least to our parent).</div><div class="line">            // This is because someone may have invalidated this view</div><div class="line">            // before this call to setFrame came in, thereby clearing</div><div class="line">            // the DRAWN bit.</div><div class="line">            mPrivateFlags |= DRAWN;</div><div class="line">            invalidate(sizeChanged);</div><div class="line">            // parent display list may need to be recreated based on a change in the bounds</div><div class="line">            // of any child</div><div class="line">            invalidateParentCaches();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Reset drawn bit to original value (invalidate turns it off)</div><div class="line">        mPrivateFlags |= drawn;</div><div class="line"></div><div class="line">        mBackgroundSizeChanged = true;</div><div class="line">    &#125;</div><div class="line">    return changed;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而scrollview 滚动时，调用的scrollTo 方法 只改变了scrollX, scrollY 的值。然后重绘，所以不会调用onlayout方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void scrollTo(int x, int y) &#123;  </div><div class="line">    if (mScrollX != x || mScrollY != y) &#123;  </div><div class="line">        int oldX = mScrollX;  </div><div class="line">        int oldY = mScrollY;  </div><div class="line">        mScrollX = x;  </div><div class="line">        mScrollY = y;  </div><div class="line">        invalidateParentCaches();  </div><div class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);  </div><div class="line">        if (!awakenScrollBars()) &#123;  </div><div class="line">            postInvalidateOnAnimation();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="View-中的-onAttachedToWindow-onDetachedFromWindow-的作用是什么？"><a href="#View-中的-onAttachedToWindow-onDetachedFromWindow-的作用是什么？" class="headerlink" title="View 中的 onAttachedToWindow onDetachedFromWindow 的作用是什么？"></a>View 中的 onAttachedToWindow onDetachedFromWindow 的作用是什么？</h2><p>这两个方法是view对自己的被add ， 被remove 的监视。<br>onAttachedToWindow 是view 本身的回调，用于初始化一些东西相当于onstart 。当view 被添加到window中，被绘制之前的回调。如addview（this view）；<br>onDetachedFromWindow 是view 本身的回调，用于销毁一些东西onstop，当view被从window中删除时的回调。如 removeview（this view）；</p><h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>onAttachedToWindow():<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">viewGroup       addview（）</div><div class="line">viewGroup       addViewInner（）</div><div class="line">view            dispatchAttachedToWindow（）</div><div class="line">onAttachedToWindow（）</div></pre></td></tr></table></figure><p></p><p>onDetachedFromWindow():<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">viewGroup     removeView（）</div><div class="line">viewGroup     removeViewInternal（）</div><div class="line">view          dispatchDetachedFromWindow（）</div><div class="line">onDetachedFromWindow（）</div></pre></td></tr></table></figure><p></p><h2 id="如何在xml中引用内部类？"><a href="#如何在xml中引用内部类？" class="headerlink" title="如何在xml中引用内部类？"></a>如何在xml中引用内部类？</h2><h3 id="ViewB继承自View"><a href="#ViewB继承自View" class="headerlink" title="ViewB继承自View"></a>ViewB继承自View</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;View    </div><div class="line">        class=&quot;com.example.ClassA$ViewB&quot;    </div><div class="line">        android:layout_width=&quot;match_parent&quot;    </div><div class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</div></pre></td></tr></table></figure><h3 id="ViewB继承自ViewGroup"><a href="#ViewB继承自ViewGroup" class="headerlink" title="ViewB继承自ViewGroup"></a>ViewB继承自ViewGroup</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;ViewGroup    </div><div class="line">    class=&quot;com.example.ClassA$ViewB&quot;    </div><div class="line">    android:layout_width=&quot;match_parent&quot;    </div><div class="line">    android:layout_height=&quot;match_parent&quot; &gt;    </div><div class="line">&lt;!-- ViewGroup内部的一些控件，比如button之类的 --&gt;    </div><div class="line">&lt;/ViewGroup&gt;</div></pre></td></tr></table></figure><h2 id="translateAnimation-setFillxxx-作用是什么？"><a href="#translateAnimation-setFillxxx-作用是什么？" class="headerlink" title="translateAnimation.setFillxxx()作用是什么？"></a>translateAnimation.setFillxxx()作用是什么？</h2><p>after,before 是用于设置动画结束之后画面停留的是哪帧。</p><h3 id="translateAnimation-setFillAfter-true"><a href="#translateAnimation-setFillAfter-true" class="headerlink" title="translateAnimation.setFillAfter(true);"></a>translateAnimation.setFillAfter(true);</h3><p>动画结束后停留在最后一帧（动画结束后画面不变）。</p><h3 id="translateAnimation-setFillBefore-true"><a href="#translateAnimation-setFillBefore-true" class="headerlink" title="translateAnimation.setFillBefore(true);"></a>translateAnimation.setFillBefore(true);</h3><p>动画结束后停留在第一帧（位置画面停留在动画开始位置）。</p><h2 id="自定义菜单时点击Menu后，自定义菜单显示，但是activity窗口没获得焦点。为什么？"><a href="#自定义菜单时点击Menu后，自定义菜单显示，但是activity窗口没获得焦点。为什么？" class="headerlink" title="自定义菜单时点击Menu后，自定义菜单显示，但是activity窗口没获得焦点。为什么？"></a>自定义菜单时点击Menu后，自定义菜单显示，但是activity窗口没获得焦点。为什么？</h2><p>自定义菜单时。一定要重写这个方法，并返回false；<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean onCreateOptionsMenu(Menu menu) &#123;  </div><div class="line">    return false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="获取View的坐标"><a href="#获取View的坐标" class="headerlink" title="获取View的坐标"></a>获取View的坐标</h2><h3 id="获取在所在父View中的坐标"><a href="#获取在所在父View中的坐标" class="headerlink" title="获取在所在父View中的坐标"></a>获取在所在父View中的坐标</h3><p>getLeft() , getTop(), getBottom(), getRight()</p><h3 id="获取在整个屏幕中的坐标"><a href="#获取在整个屏幕中的坐标" class="headerlink" title="获取在整个屏幕中的坐标"></a>获取在整个屏幕中的坐标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int[] location = new int[2];</div><div class="line">View.getLocationOnScreen(location);</div><div class="line">int x = location[0];</div><div class="line">int y = location[1];</div></pre></td></tr></table></figure><h3 id="获取在所在Activity的window中的坐标"><a href="#获取在所在Activity的window中的坐标" class="headerlink" title="获取在所在Activity的window中的坐标"></a>获取在所在Activity的window中的坐标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int[] location = new int[2];</div><div class="line">View.getLocationInWindow(location);</div><div class="line">int x = location[0];</div><div class="line">int y = location[1];</div></pre></td></tr></table></figure><h3 id="getLocalVisibleRect"><a href="#getLocalVisibleRect" class="headerlink" title="getLocalVisibleRect"></a>getLocalVisibleRect</h3><p>获取视图本身可见的坐标区域，坐标以自己的左上角为原点（0，0）</p><h3 id="getGlobalVisibleRect"><a href="#getGlobalVisibleRect" class="headerlink" title="getGlobalVisibleRect"></a>getGlobalVisibleRect</h3><p>获取视图在屏幕坐标中的可视区域</p><h2 id="canvas的画文字方法参数的意义？"><a href="#canvas的画文字方法参数的意义？" class="headerlink" title="canvas的画文字方法参数的意义？"></a>canvas的画文字方法参数的意义？</h2><p>canvas.drawText(String text, float x, float y, Paint paint)<br>y 参数的意义是文字的底部的坐标。</p><h2 id="像素的结构"><a href="#像素的结构" class="headerlink" title="像素的结构"></a>像素的结构</h2><p>颜色（一个像素用一个int表示，32位真彩色）<br><img src="/images/pixel.jpg" alt=""><br>alpha通道：透明度，0~255 共256级透明度<br>一张图片所占内存 = wide <em>hight </em>4 byte</p><h2 id="canvas如何画出缩放的bitmap"><a href="#canvas如何画出缩放的bitmap" class="headerlink" title="canvas如何画出缩放的bitmap"></a>canvas如何画出缩放的bitmap</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) &#123;  </div><div class="line">    if (dst == null) &#123;  </div><div class="line">        throw new NullPointerException();  </div><div class="line">    &#125;  </div><div class="line">    throwIfRecycled(bitmap);  </div><div class="line">    native_drawBitmap(mNativeCanvas, bitmap.ni(), src, dst,  </div><div class="line">                      paint != null ? paint.mNativePaint : 0,  </div><div class="line">                      mScreenDensity, bitmap.mDensity);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Rect src: 是对图片进行裁截，若是null则显示整个图片<br>Rect dst：是图片在Canvas画布中显示的区域，大于src则把src的裁截区放大，小于src则把src的裁截区缩小。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 定义矩阵对象  </div><div class="line">Matrix matrix=new Matrix(); </div><div class="line">// 缩放原图  </div><div class="line">matrix.postScale(0.5f, 0.5f); </div><div class="line">Bitmap dstbmp=Bitmap.createBitmap(bmp,0,0,bmp.getWidth(),bmp.getHeight(),matrix,true);</div></pre></td></tr></table></figure><h2 id="View自定义长按菜单实现"><a href="#View自定义长按菜单实现" class="headerlink" title="View自定义长按菜单实现"></a>View自定义长按菜单实现</h2><h3 id="触发流程"><a href="#触发流程" class="headerlink" title="触发流程"></a>触发流程</h3><p>响应view：ontouch() –&gt; performLongClick() –&gt; showContextMenu()<br>调用根容器：–&gt; getparent().showContextMenuForChild（this）会一层层将响应长按的view传递至父容器。</p><h3 id="响应逻辑"><a href="#响应逻辑" class="headerlink" title="响应逻辑"></a>响应逻辑</h3><p>在根容器中重写 showContextMenuForChild（View originalView）进行处理。</p><ol><li>originalView.onCreateContextMenu() 装填内容，originalView必须提供getContextMenuInfo()方法</li><li>showmenu()</li></ol><h2 id="计算android-view的FPS"><a href="#计算android-view的FPS" class="headerlink" title="计算android view的FPS"></a>计算android view的FPS</h2><p>FPS : frame per second 刷新率 ，每秒绘制的帧数。</p><h3 id="如何计算："><a href="#如何计算：" class="headerlink" title="如何计算："></a>如何计算：</h3><p>在onDraw() 方法中进行逻辑计算<br>每调用一次onDraw() 方法，则frame 加 1；<br>因为绘制每帧的时间不同，所以<br>当时间刚好大于1秒的时候，进行计算。<br>如绘制了60帧，刚好用了1.2秒<br>则 fps ＝ 60 / 1.2；<br>fps ＝ 50 帧/秒；</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"></div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line"></div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">//耗时的绘制</div><div class="line"></div><div class="line">draw。。。。。。。。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    // fps counter: count how many frames we draw and once a second calculate the</div><div class="line"></div><div class="line">    // frames per second</div><div class="line"></div><div class="line">    ++frames;</div><div class="line"></div><div class="line">    long nowTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">    long deltaTime = nowTime - startTime;</div><div class="line"></div><div class="line">    if (deltaTime &gt; 1000) &#123;</div><div class="line"></div><div class="line">        float secs = (float) deltaTime / 1000f;</div><div class="line"></div><div class="line">        fps = (float) frames / secs;</div><div class="line"></div><div class="line">        fpsString = &quot;fps: &quot; + fps;</div><div class="line"></div><div class="line">        startTime = nowTime;</div><div class="line"></div><div class="line">        frames = 0;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">   canvas.drawText(fpsString, getWidth() - 200, getHeight() - 80, textPaint);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="android中改变view位置的几种方法"><a href="#android中改变view位置的几种方法" class="headerlink" title="android中改变view位置的几种方法"></a>android中改变view位置的几种方法</h2><h3 id="调用-layout方法"><a href="#调用-layout方法" class="headerlink" title="调用 layout方法"></a>调用 layout方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">    int oldL = mLeft;</div><div class="line">    int oldT = mTop;</div><div class="line">    int oldB = mBottom;</div><div class="line">    int oldR = mRight;</div><div class="line">    boolean changed = setFrame(l, t, r, b);</div><div class="line">    if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;</div><div class="line">        if (ViewDebug.TRACE_HIERARCHY) &#123;</div><div class="line">            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_LAYOUT);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        onLayout(changed, l, t, r, b);</div><div class="line">        mPrivateFlags &amp;= ~LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">        if (mOnLayoutChangeListeners != null) &#123;</div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;) mOnLayoutChangeListeners.clone();</div><div class="line">            int numListeners = listenersCopy.size();</div><div class="line">            for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class="line">                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mPrivateFlags &amp;= ~FORCE_LAYOUT;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="设置MarginLayoutParams，-然后调用setLayoutParams"><a href="#设置MarginLayoutParams，-然后调用setLayoutParams" class="headerlink" title="设置MarginLayoutParams， 然后调用setLayoutParams()"></a>设置MarginLayoutParams， 然后调用setLayoutParams()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void setLayoutParams(ViewGroup.LayoutParams params) &#123;</div><div class="line">    if (params == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;Layout parameters cannot be null&quot;);</div><div class="line">    &#125;</div><div class="line">    mLayoutParams = params;</div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="外容器scrollTo-方法。改变view窗体位置。会改变所有的子View位置"><a href="#外容器scrollTo-方法。改变view窗体位置。会改变所有的子View位置" class="headerlink" title="外容器scrollTo 方法。改变view窗体位置。会改变所有的子View位置"></a>外容器scrollTo 方法。改变view窗体位置。会改变所有的子View位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void scrollTo(int x, int y) &#123;  </div><div class="line">    if (mScrollX != x || mScrollY != y) &#123;  </div><div class="line">        int oldX = mScrollX;  </div><div class="line">        int oldY = mScrollY;  </div><div class="line">        mScrollX = x;  </div><div class="line">        mScrollY = y;  </div><div class="line">        invalidateParentCaches();  </div><div class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);  </div><div class="line">        if (!awakenScrollBars()) &#123;  </div><div class="line">            invalidate(true);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="view-的scroll系列方法的理解"><a href="#view-的scroll系列方法的理解" class="headerlink" title="view 的scroll系列方法的理解"></a>view 的scroll系列方法的理解</h2><h3 id="scrollTo"><a href="#scrollTo" class="headerlink" title="scrollTo():"></a>scrollTo():</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void scrollTo(int x, int y) &#123;  </div><div class="line">    if (mScrollX != x || mScrollY != y) &#123;  </div><div class="line">        int oldX = mScrollX;  </div><div class="line">        int oldY = mScrollY;  </div><div class="line">        mScrollX = x;  </div><div class="line">        mScrollY = y;  </div><div class="line">        invalidateParentCaches();  </div><div class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);  </div><div class="line">        if (!awakenScrollBars()) &#123;  </div><div class="line">            invalidate(true);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="scrollBy"><a href="#scrollBy" class="headerlink" title="scrollBy()"></a>scrollBy()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void scrollBy(int x, int y) &#123;  </div><div class="line">    scrollTo(mScrollX + x, mScrollY + y);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="setScrollX"><a href="#setScrollX" class="headerlink" title="setScrollX"></a>setScrollX</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void setScrollX(int value) &#123;  </div><div class="line">    scrollTo(value, mScrollY);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="setScrollY"><a href="#setScrollY" class="headerlink" title="setScrollY"></a>setScrollY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void setScrollY(int value) &#123;  </div><div class="line">    scrollTo(mScrollX, value);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>scroll方法针对的是view中的内容。<br>如view.scrollTo(50,0); 表示的是针对内容的（0，0）坐标view滚动了50个像素。<br>展现的是，内容向左边移动了50个像素。<br><img src="/images/scroll.png" alt=""></p><h2 id="LayoutInflater-的inflate-int-resource-ViewGroup-root-boolean-attachToRoot-方法研究"><a href="#LayoutInflater-的inflate-int-resource-ViewGroup-root-boolean-attachToRoot-方法研究" class="headerlink" title="LayoutInflater 的inflate(int resource, ViewGroup root, boolean attachToRoot)方法研究"></a>LayoutInflater 的inflate(int resource, ViewGroup root, boolean attachToRoot)方法研究</h2><h3 id="情况一：-root-null-attachToRoot-false"><a href="#情况一：-root-null-attachToRoot-false" class="headerlink" title="情况一： root =null,  attachToRoot = false;"></a>情况一： root =null, attachToRoot = false;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">View temp = createViewFromTag(root, name, attrs);  </div><div class="line">  </div><div class="line">// Inflate all children under temp  </div><div class="line">rInflate(parser, temp, attrs, true);  </div><div class="line">  </div><div class="line">return temp;</div></pre></td></tr></table></figure><h3 id="情况二：root-null-attachToRoot-false"><a href="#情况二：root-null-attachToRoot-false" class="headerlink" title="情况二：root != null, attachToRoot = false;"></a>情况二：root != null, attachToRoot = false;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">View temp = createViewFromTag(root, name, attrs);  </div><div class="line">  </div><div class="line">ViewGroup.LayoutParams params = root.generateLayoutParams(attrs);  </div><div class="line">temp.setLayoutParams(params);  </div><div class="line">  </div><div class="line">// Inflate all children under temp  </div><div class="line">rInflate(parser, temp, attrs, true);  </div><div class="line">  </div><div class="line">return temp;</div></pre></td></tr></table></figure><h3 id="情况三：root-null-attachToRoot-true"><a href="#情况三：root-null-attachToRoot-true" class="headerlink" title="情况三：root != null, attachToRoot = true;"></a>情况三：root != null, attachToRoot = true;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">View temp = createViewFromTag(root, name, attrs);  </div><div class="line">  </div><div class="line">ViewGroup.LayoutParams params = root.generateLayoutParams(attrs);  </div><div class="line">temp.setLayoutParams(params);  </div><div class="line">  </div><div class="line">// Inflate all children under temp  </div><div class="line">rInflate(parser, temp, attrs, true);  </div><div class="line">  </div><div class="line">root.addView(temp, params);  </div><div class="line">  </div><div class="line">return root;</div></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="root为空时"><a href="#root为空时" class="headerlink" title="root为空时"></a>root为空时</h4><p>返回temp。</p><h4 id="root-不为空时"><a href="#root-不为空时" class="headerlink" title="root 不为空时"></a>root 不为空时</h4><p>attachToRoot = true 。返回root；<br>attachToRoot = false。设置temp layoutParams 。返回temp。</p><h2 id="ViewPager-SimpleOnPageChangeListener中回调函数的调用场景"><a href="#ViewPager-SimpleOnPageChangeListener中回调函数的调用场景" class="headerlink" title="ViewPager SimpleOnPageChangeListener中回调函数的调用场景"></a>ViewPager SimpleOnPageChangeListener中回调函数的调用场景</h2><p>Listener 的源码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">240     public static class SimpleOnPageChangeListener implements OnPageChangeListener &#123;  </div><div class="line">241         @Override  </div><div class="line">242         public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;  </div><div class="line">243             // This space for rent  </div><div class="line">244         &#125;  </div><div class="line">245   </div><div class="line">246         @Override  </div><div class="line">247         public void onPageSelected(int position) &#123;  </div><div class="line">248             // This space for rent  </div><div class="line">249         &#125;  </div><div class="line">250   </div><div class="line">251         @Override  </div><div class="line">252         public void onPageScrollStateChanged(int state) &#123;  </div><div class="line">253             // This space for rent  </div><div class="line">254         &#125;  </div><div class="line">255     &#125;</div></pre></td></tr></table></figure><p></p><h3 id="1-onPageScrolled-int-position-float-positionOffset-int-positionOffsetPixels-："><a href="#1-onPageScrolled-int-position-float-positionOffset-int-positionOffsetPixels-：" class="headerlink" title="1.onPageScrolled(int position, float positionOffset, int positionOffsetPixels)："></a>1.onPageScrolled(int position, float positionOffset, int positionOffsetPixels)：</h3><p>position:当前的位置<br>positionoffset:当前滚动比例（左－右／0-1）（右－左／1-0）<br>positionOffsetPixels：当前实际滚动的像素（左－右／0-页宽） （右－左／页宽－0）</p><h4 id="被调用的场景"><a href="#被调用的场景" class="headerlink" title="被调用的场景:"></a>被调用的场景:</h4><p>ViewPager滚动时总被回调，这个函数在操作ViewPager时被回调很多次。<br>1.手指拖动 action_move 。n次<br>2.惯性还原 computeScroll()。n次</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>做view的动画效果时可以用这个回调函数。</p><h3 id="2-onPageSelected-int-position"><a href="#2-onPageSelected-int-position" class="headerlink" title="2.onPageSelected(int position)"></a>2.onPageSelected(int position)</h3><h4 id="被调用的场景："><a href="#被调用的场景：" class="headerlink" title="被调用的场景："></a>被调用的场景：</h4><p>ViewPager确定页面是哪一页时。1次</p><ol><li>手指拖动后抬起 action_up 。1次</li><li>或者手指滑动超出屏幕时 action_cancel。1次<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4>页面切换后改变对应的tab的状态可以用这个回调函数。<h3 id="3-onPageScrollStateChanged-int-state"><a href="#3-onPageScrollStateChanged-int-state" class="headerlink" title="3.onPageScrollStateChanged(int state):"></a>3.onPageScrollStateChanged(int state):</h3><h4 id="被调用的场景：-1"><a href="#被调用的场景：-1" class="headerlink" title="被调用的场景："></a>被调用的场景：</h4>ViewPager状态切换时被调用。这个函数在操作ViewPager时被回调3次。<br>1.开始滚动 dragging拖动状态。1次<br>2.惯性滚动 settling还原状态。1次<br>3.滚动结束 idle空闲状态。1次<h4 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h4>做页面状态变化后引起的view特效时可以用这个回调函数</li></ol><h2 id="TextView-setEms-方法名字"><a href="#TextView-setEms-方法名字" class="headerlink" title="TextView setEms 方法名字"></a>TextView setEms 方法名字</h2><p>Android TextView setEms() 作用是设置textview的字符宽度。但是名字很奇怪。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * Makes the TextView exactly this many ems wide </div><div class="line"> * </div><div class="line"> * @attr ref android.R.styleable#TextView_ems </div><div class="line"> */  </div><div class="line">@android.view.RemotableViewMethod  </div><div class="line">public void setEms(int ems) &#123;  </div><div class="line">    mMaxWidth = mMinWidth = ems;  </div><div class="line">    mMaxWidthMode = mMinWidthMode = EMS;  </div><div class="line">  </div><div class="line">    requestLayout();  </div><div class="line">    invalidate();  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>An em is a unit in the field of typography<br>em是一个印刷排版的单位，表示字宽的单位。 em字面意思为：equal M （和M字符一致的宽度为一个单位）简称em。<br>ems是em的复数表达。<br><a href="http://en.wikipedia.org/wiki/Em_%28typography%29" target="_blank" rel="noopener">em 的具体来历？</a></p><h2 id="View容器-measure-流程"><a href="#View容器-measure-流程" class="headerlink" title="View容器 measure 流程"></a>View容器 measure 流程</h2><h3 id="FrameLayout-onMeasure"><a href="#FrameLayout-onMeasure" class="headerlink" title="FrameLayout onMeasure()"></a>FrameLayout onMeasure()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.    measureChildWithMargins() ViewGroup.Java</div><div class="line">1.1   getChildMeasureSpec()     ViewGroup.java</div><div class="line">1.2   child.measure()  View.java</div><div class="line">1.2.1 chlid.onMeasure()        </div><div class="line"></div><div class="line">2.    resolveSizeAndState()     View.java</div><div class="line">3.    setMeasuredDimension()    View.java</div></pre></td></tr></table></figure><h3 id="LinearLayout-onMeasure"><a href="#LinearLayout-onMeasure" class="headerlink" title="LinearLayout onMeasure()"></a>LinearLayout onMeasure()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.    measureChildWithMargins() ViewGroup.java</div><div class="line">1.1   getChildMeasureSpec()     ViewGroup.java</div><div class="line">1.2   child.measure()  View.java</div><div class="line">1.2.1 chlid.onMeasure()        </div><div class="line"></div><div class="line">2.    resolveSizeAndState()     View.java</div><div class="line">3.    setMeasuredDimension()    View.java</div></pre></td></tr></table></figure><h3 id="RelateveLayout-onMeasure"><a href="#RelateveLayout-onMeasure" class="headerlink" title="RelateveLayout onMeasure()"></a>RelateveLayout onMeasure()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.    measureChild()            RelateveLayout.java</div><div class="line">1.1   getChildMeasureSpec()     RelateveLayout.java</div><div class="line">1.2   child.measure()  View.java</div><div class="line">1.2.1 chlid.onMeasure()        </div><div class="line"></div><div class="line">2.    resolveSizeAndState()    View.java</div><div class="line">3.    setMeasuredDimension()    View.java</div></pre></td></tr></table></figure><h3 id="AbsoluteLayout-onMeasure"><a href="#AbsoluteLayout-onMeasure" class="headerlink" title="AbsoluteLayout onMeasure()"></a>AbsoluteLayout onMeasure()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.    measureChildren()         ViewGroup.java</div><div class="line">1.1   getChildMeasureSpec()     ViewGroup.java</div><div class="line">1.2   child.measure()  View.java</div><div class="line">1.2.1 chlid.onMeasure()        </div><div class="line"></div><div class="line">2.    resolveSizeAndState()    View.java</div><div class="line">3.    setMeasuredDimension()    View.java</div></pre></td></tr></table></figure><hr><h1 id="window"><a href="#window" class="headerlink" title="window"></a>window</h1><h2 id="animation-1"><a href="#animation-1" class="headerlink" title="animation"></a>animation</h2><h3 id="启动动画"><a href="#启动动画" class="headerlink" title="启动动画"></a>启动动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">startActivity(new Intent(A.this, B.class));  </div><div class="line">overridePendingTransition(inAnim, outAnim);</div></pre></td></tr></table></figure><h3 id="结束动画"><a href="#结束动画" class="headerlink" title="结束动画"></a>结束动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">finish();  </div><div class="line">activity.overridePendingTransition(inAnim, outAnim);</div></pre></td></tr></table></figure><h3 id="全局activity动画"><a href="#全局activity动画" class="headerlink" title="全局activity动画"></a>全局activity动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;Theme.Test&quot; parent=&quot;@android:style/Theme.Light.NoTitleBar&quot;&gt;  </div><div class="line">    &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/Animation.Activity.Test&lt;/item&gt;  </div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;Animation.Activity.Test&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt;  </div><div class="line">    &lt;item name=&quot;android:activityOpenEnterAnimation&quot;&gt;@anim/activity_open_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:activityOpenExitAnimation&quot;&gt;@anim/activity_open_exit&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:activityCloseEnterAnimation&quot;&gt;@anim/activity_close_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:activityCloseExitAnimation&quot;&gt;@anim/activity_close_exit&lt;/item&gt;  </div><div class="line">             </div><div class="line">    &lt;item name=&quot;android:taskOpenEnterAnimation&quot;&gt;@anim/activity_open_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskOpenExitAnimation&quot;&gt;@anim/activity_open_exit&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskCloseEnterAnimation&quot;&gt;@anim/activity_close_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskCloseExitAnimation&quot;&gt;@anim/activity_close_exit&lt;/item&gt;  </div><div class="line">             </div><div class="line">    &lt;item name=&quot;android:taskToFrontEnterAnimation&quot;&gt;@anim/activity_open_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskToFrontExitAnimation&quot;&gt;@anim/activity_open_exit&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskToBackEnterAnimation&quot;&gt;@anim/activity_close_enter&lt;/item&gt;  </div><div class="line">    &lt;item name=&quot;android:taskToBackExitAnimation&quot;&gt;@anim/activity_close_exit&lt;/item&gt;  </div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure><h2 id="不影响系统交互的悬浮窗window参数设置"><a href="#不影响系统交互的悬浮窗window参数设置" class="headerlink" title="不影响系统交互的悬浮窗window参数设置"></a>不影响系统交互的悬浮窗window参数设置</h2><p>type: Z-Order<br>表示window层级关系的变量<br>应用类型的窗口的type范围是１~99（activity window）<br>子窗口的type范围是1000~1999（PopWindow，Dialog）<br>系统的窗口的type范围是2000以上<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WindowManager.LayoutParams.TYPE_TOAST</div></pre></td></tr></table></figure><p></p><p>flag：窗口控制的标记<br>常亮，焦点，操作 等控制<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON</div><div class="line">WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|</div><div class="line">        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if (mVolumeView == null) &#123;  </div><div class="line">    WindowManager mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);  </div><div class="line">    View rootView = View.inflate(context, R.layout.volume_layout, null);  </div><div class="line">    mVolumeView = (VolumeView) rootView.findViewById(R.id.volume);  </div><div class="line">    WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(  </div><div class="line">            WindowManager.LayoutParams.MATCH_PARENT,  </div><div class="line">            WindowManager.LayoutParams.MATCH_PARENT,  </div><div class="line">            WindowManager.LayoutParams.TYPE_TOAST,  </div><div class="line">            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|  </div><div class="line">                    WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,  </div><div class="line">            PixelFormat.TRANSLUCENT);  </div><div class="line">    layoutParams.gravity = Gravity.TOP;  </div><div class="line">    mWindowManager.addView(rootView, layoutParams);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="如何监听window的back键"><a href="#如何监听window的back键" class="headerlink" title="如何监听window的back键"></a>如何监听window的back键</h2><p>可以重写window的根view的dispatchKeyEvent方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">WindowManager mWindowManager = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);  </div><div class="line">Display display = mWindowManager.getDefaultDisplay();  </div><div class="line">int width = display.getWidth();  </div><div class="line">int height = display.getHeight();  </div><div class="line">int statusBarHeight = getStatusBarHeight();  </div><div class="line">final PopupWindow pw = new PopupWindow(width, height - statusBarHeight);  </div><div class="line">  </div><div class="line">final FrameLayout container = new FrameLayout(getContext())&#123;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public boolean dispatchKeyEvent(KeyEvent event) &#123;  </div><div class="line">        if(event.getAction() == KeyEvent.ACTION_UP) &#123;  </div><div class="line">            if(event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123;  </div><div class="line">                Log.addLog(this, &quot;window height =&quot; + pw.getHeight());  </div><div class="line">                removeAllViews();  </div><div class="line">                pw.dismiss();  </div><div class="line">                return true;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return super.dispatchKeyEvent(event);  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;;  </div><div class="line">container.addView(view, params);  </div><div class="line">pw.setContentView(container);  </div><div class="line">pw.setFocusable(true);  </div><div class="line">pw.setAnimationStyle(R.style.popUpWindowAnimation);  </div><div class="line">pw.showAtLocation(this, Gravity.NO_GRAVITY, 0, statusBarHeight);</div></pre></td></tr></table></figure><p></p><hr><h1 id="修改app-默认动画"><a href="#修改app-默认动画" class="headerlink" title="修改app 默认动画"></a>修改app 默认动画</h1><p>在activity中添加overridePendingTransition即可满足 应用启动activity和应用中activity间切换时的动画一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    setContentView(R.layout.main_dashboard);</div><div class="line">    overridePendingTransition(R.anim.activity_open_enter, R.anim.activity_open_exit);//添加启动动画</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void finish() &#123;</div><div class="line">    super.finish();</div><div class="line">    overridePendingTransition(R.anim.activity_close_enter, R.anim.activity_close_exit);//添加退出动画</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h1 id="设备的适配"><a href="#设备的适配" class="headerlink" title="设备的适配"></a>设备的适配</h1><p><a href="https://developer.android.google.cn/guide/practices/screens_support.html?hl=zh-cn" target="_blank" rel="noopener">官方文档</a><br><img src="/images/fitres.jpeg" alt=""></p><h2 id="一套代码适配不同屏幕设备。"><a href="#一套代码适配不同屏幕设备。" class="headerlink" title="一套代码适配不同屏幕设备。"></a>一套代码适配不同屏幕设备。</h2><p>原理：通过修改density保证任意分辨率设备按密度比率进行像素缩放，纵向可滚动。<br>接口：提供的接口保证可以缩放activity内的显示效果，并且能还原缩放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public class DensityUtil &#123;</div><div class="line"></div><div class="line">    private static float mNonCompatDensity;</div><div class="line">    private static int mNonCompatDensityDpi;</div><div class="line">    private static float mNonCompatScaledDensity;</div><div class="line"></div><div class="line">    public static void fitDensity(@NonNull Activity activity, @NonNull final Application application, int designWith) &#123;</div><div class="line">        final DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics();</div><div class="line"></div><div class="line">        if (mNonCompatDensity == 0) &#123;</div><div class="line">            mNonCompatDensity = appDisplayMetrics.density;</div><div class="line">            mNonCompatDensityDpi = appDisplayMetrics.densityDpi;</div><div class="line">            mNonCompatScaledDensity = appDisplayMetrics.scaledDensity;</div><div class="line">            application.registerComponentCallbacks(new ComponentCallbacks() &#123;</div><div class="line">                @Override</div><div class="line">                public void onConfigurationChanged(Configuration newConfig) &#123;</div><div class="line">                    if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) &#123;</div><div class="line">                        mNonCompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onLowMemory() &#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final float targetDensity = appDisplayMetrics.widthPixels * 1.0f / designWith;</div><div class="line">        final int targetDensityDpi = (int) (160 * targetDensity);</div><div class="line">        final float targetScaledDensity = targetDensity * (mNonCompatScaledDensity / mNonCompatDensity);</div><div class="line"></div><div class="line">        appDisplayMetrics.density = targetDensity;</div><div class="line">        appDisplayMetrics.densityDpi = targetDensityDpi;</div><div class="line">        appDisplayMetrics.scaledDensity = targetScaledDensity;</div><div class="line"></div><div class="line">        final DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics();</div><div class="line">        activityDisplayMetrics.density = targetDensity;</div><div class="line">        activityDisplayMetrics.densityDpi = targetDensityDpi;</div><div class="line">        activityDisplayMetrics.scaledDensity = targetScaledDensity;</div><div class="line">        Log.i(&quot;peter&quot;, &quot; appDisplayMetrics.density :&quot; + appDisplayMetrics.density + &quot;;appDisplayMetrics&quot;</div><div class="line">                + &quot;.scaledDensity:&quot; + appDisplayMetrics.scaledDensity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void resetFit(@NonNull final Application application) &#123;</div><div class="line">        final DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics();</div><div class="line">        if (mNonCompatDensity != 0) &#123;</div><div class="line">            appDisplayMetrics.density = mNonCompatDensity;</div><div class="line">            appDisplayMetrics.densityDpi = mNonCompatDensityDpi;</div><div class="line">            appDisplayMetrics.scaledDensity = mNonCompatScaledDensity;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="不透明度列表"><a href="#不透明度列表" class="headerlink" title="不透明度列表"></a>不透明度列表</h1><p>注：view.setAlpha(0.5)是全局的<br>会导致view的子view全部都变成这个透明度</p><table><thead><tr><th>不透明度</th><th style="text-align:left">数值</th></tr></thead><tbody><tr><td>0%</td><td style="text-align:left">00</td></tr><tr><td>1%</td><td style="text-align:left">03</td></tr><tr><td>2%</td><td style="text-align:left">05</td></tr><tr><td>3%</td><td style="text-align:left">08</td></tr><tr><td>4%</td><td style="text-align:left">0A</td></tr><tr><td>5%</td><td style="text-align:left">0D</td></tr><tr><td>6%</td><td style="text-align:left">0F</td></tr><tr><td>7%</td><td style="text-align:left">12</td></tr><tr><td>8%</td><td style="text-align:left">14</td></tr><tr><td>9%</td><td style="text-align:left">17</td></tr><tr><td>10%</td><td style="text-align:left">1A</td></tr><tr><td>11%</td><td style="text-align:left">1C</td></tr><tr><td>12%</td><td style="text-align:left">1F</td></tr><tr><td>13%</td><td style="text-align:left">21</td></tr><tr><td>14%</td><td style="text-align:left">24</td></tr><tr><td>15%</td><td style="text-align:left">26</td></tr><tr><td>16%</td><td style="text-align:left">29</td></tr><tr><td>17%</td><td style="text-align:left">2B</td></tr><tr><td>18%</td><td style="text-align:left">2E</td></tr><tr><td>19%</td><td style="text-align:left">30</td></tr><tr><td>20%</td><td style="text-align:left">33</td></tr><tr><td>21%</td><td style="text-align:left">36</td></tr><tr><td>22%</td><td style="text-align:left">38</td></tr><tr><td>23%</td><td style="text-align:left">3B</td></tr><tr><td>24%</td><td style="text-align:left">3D</td></tr><tr><td>25%</td><td style="text-align:left">40</td></tr><tr><td>26%</td><td style="text-align:left">42</td></tr><tr><td>27%</td><td style="text-align:left">45</td></tr><tr><td>28%</td><td style="text-align:left">47</td></tr><tr><td>29%</td><td style="text-align:left">4A</td></tr><tr><td>30%</td><td style="text-align:left">4D</td></tr><tr><td>31%</td><td style="text-align:left">4F</td></tr><tr><td>32%</td><td style="text-align:left">52</td></tr><tr><td>33%</td><td style="text-align:left">54</td></tr><tr><td>34%</td><td style="text-align:left">57</td></tr><tr><td>35%</td><td style="text-align:left">59</td></tr><tr><td>36%</td><td style="text-align:left">5C</td></tr><tr><td>37%</td><td style="text-align:left">5E</td></tr><tr><td>38%</td><td style="text-align:left">61</td></tr><tr><td>39%</td><td style="text-align:left">63</td></tr><tr><td>40%</td><td style="text-align:left">66</td></tr><tr><td>41%</td><td style="text-align:left">69</td></tr><tr><td>42%</td><td style="text-align:left">6B</td></tr><tr><td>43%</td><td style="text-align:left">6E</td></tr><tr><td>44%</td><td style="text-align:left">70</td></tr><tr><td>45%</td><td style="text-align:left">73</td></tr><tr><td>46%</td><td style="text-align:left">75</td></tr><tr><td>47%</td><td style="text-align:left">78</td></tr><tr><td>48%</td><td style="text-align:left">7A</td></tr><tr><td>49%</td><td style="text-align:left">7D</td></tr><tr><td>50%</td><td style="text-align:left">80</td></tr><tr><td>51%</td><td style="text-align:left">82</td></tr><tr><td>52%</td><td style="text-align:left">85</td></tr><tr><td>53%</td><td style="text-align:left">87</td></tr><tr><td>54%</td><td style="text-align:left">8A</td></tr><tr><td>55%</td><td style="text-align:left">8C</td></tr><tr><td>56%</td><td style="text-align:left">8F</td></tr><tr><td>57%</td><td style="text-align:left">91</td></tr><tr><td>58%</td><td style="text-align:left">94</td></tr><tr><td>59%</td><td style="text-align:left">96</td></tr><tr><td>60%</td><td style="text-align:left">99</td></tr><tr><td>61%</td><td style="text-align:left">9C</td></tr><tr><td>62%</td><td style="text-align:left">9E</td></tr><tr><td>63%</td><td style="text-align:left">A1</td></tr><tr><td>64%</td><td style="text-align:left">A3</td></tr><tr><td>65%</td><td style="text-align:left">A6</td></tr><tr><td>66%</td><td style="text-align:left">A8</td></tr><tr><td>67%</td><td style="text-align:left">AB</td></tr><tr><td>68%</td><td style="text-align:left">AD</td></tr><tr><td>69%</td><td style="text-align:left">B0</td></tr><tr><td>70%</td><td style="text-align:left">B3</td></tr><tr><td>71%</td><td style="text-align:left">B5</td></tr><tr><td>72%</td><td style="text-align:left">B8</td></tr><tr><td>73%</td><td style="text-align:left">BA</td></tr><tr><td>74%</td><td style="text-align:left">BD</td></tr><tr><td>75%</td><td style="text-align:left">BF</td></tr><tr><td>76%</td><td style="text-align:left">C2</td></tr><tr><td>77%</td><td style="text-align:left">C4</td></tr><tr><td>78%</td><td style="text-align:left">C7</td></tr><tr><td>79%</td><td style="text-align:left">C9</td></tr><tr><td>80%</td><td style="text-align:left">CC</td></tr><tr><td>81%</td><td style="text-align:left">CF</td></tr><tr><td>82%</td><td style="text-align:left">D1</td></tr><tr><td>83%</td><td style="text-align:left">D4</td></tr><tr><td>84%</td><td style="text-align:left">D6</td></tr><tr><td>85%</td><td style="text-align:left">D9</td></tr><tr><td>86%</td><td style="text-align:left">DB</td></tr><tr><td>87%</td><td style="text-align:left">DE</td></tr><tr><td>88%</td><td style="text-align:left">E0</td></tr><tr><td>89%</td><td style="text-align:left">E3</td></tr><tr><td>90%</td><td style="text-align:left">E6</td></tr><tr><td>91%</td><td style="text-align:left">E8</td></tr><tr><td>92%</td><td style="text-align:left">EB</td></tr><tr><td>93%</td><td style="text-align:left">ED</td></tr><tr><td>94%</td><td style="text-align:left">F0</td></tr><tr><td>95%</td><td style="text-align:left">F2</td></tr><tr><td>96%</td><td style="text-align:left">F5</td></tr><tr><td>97%</td><td style="text-align:left">F7</td></tr><tr><td>98%</td><td style="text-align:left">FA</td></tr><tr><td>99%</td><td style="text-align:left">FC</td></tr><tr><td>100%</td><td style="text-align:left">FF</td></tr></tbody></table><h1 id="增加view-触摸面积"><a href="#增加view-触摸面积" class="headerlink" title="增加view 触摸面积"></a>增加view 触摸面积</h1><h2 id="设置padding"><a href="#设置padding" class="headerlink" title="设置padding"></a>设置padding</h2><h2 id="使用TouchDelegate"><a href="#使用TouchDelegate" class="headerlink" title="使用TouchDelegate"></a>使用TouchDelegate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">llayout.post(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        llayout.setTouchDelegate(new TouchDelegate(</div><div class="line">                new Rect(0, 0, llayout.getMeasuredWidth()/2, llayout.getMeasuredHeight()), img));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h1 id="VSync"><a href="#VSync" class="headerlink" title="VSync"></a>VSync</h1><h2 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h2><p>即 Frame Rate，单位 fps，是指 gpu 生成帧的速率，如 33 fps，60fps，越高越好。</p><h2 id="屏幕刷新频率"><a href="#屏幕刷新频率" class="headerlink" title="屏幕刷新频率"></a>屏幕刷新频率</h2><p>即 Refresh Rate 或 Scanning Frequency，单位赫兹/Hz，是指设备刷新屏幕的频率，该值对于特定的设备来说是个常量，如 60hz。<br>对于一个特定的设备，帧率和刷新频率没有必然的大小关系。<br><img src="/images/screen_refresh.jpg" alt=""></p><h2 id="VSync-1"><a href="#VSync-1" class="headerlink" title="VSync"></a>VSync</h2><p>屏幕的刷新过程是每一行从左到右（行刷新，水平刷新，Horizontal Scanning），从上到下（屏幕刷新，垂直刷新，Vertical Scanning）。当整个屏幕刷新完毕，即一个垂直刷新周期完成，会有短暂的空白期，此时发出 VSync 信号。所以，VSync 中的 V 指的是垂直刷新中的垂直/Vertical。</p><p>安卓系统中有 2 种 VSync 信号：屏幕产生的硬件 VSync 和由 SurfaceFlinger 将其转成的软件 Vsync 信号。后者经由 Binder 传递给 Choreographer。<br>硬件 VSync 是一个脉冲信号，起到开关或触发某种操作的作用。</p><h2 id="单缓存"><a href="#单缓存" class="headerlink" title="单缓存"></a>单缓存</h2><p>CPU/GPU 向 Buffer 中生成图像，屏幕从 Buffer 中取图像、刷新后显示。这是一个典型的生产者——消费者模型。<br>理想的情况是帧率和刷新频率相等，每绘制一帧，屏幕显示一帧。而实际情况是，二者之间没有必然的大小关系，如果没有锁来控制同步，很容易出现问题。例如，当帧率大于刷新频率，当屏幕还没有刷新第 n-1 帧的时候，GPU 已经在生成第 n 帧了，从上往下开始覆盖第 n-1 帧的数据，当屏幕开始刷新第 n-1 帧的时候，Buffer 中的数据上半部分是第 n 帧数据，而下半部分是第 n-1 帧的数据，显示出来的图像就会出现上半部分和下半部分明显偏差的现象，我们称之为 “tearing”<br><img src="/images/one_buffer.jpg" alt=""></p><h2 id="双缓存（Double-Buffer）"><a href="#双缓存（Double-Buffer）" class="headerlink" title="双缓存（Double Buffer）"></a>双缓存（Double Buffer）</h2><p>为了解决单缓存的“tearing”问题，双重缓存和 VSync 应运而生。<br>两个缓存区分别为 Back Buffer 和 Frame Buffer。GPU 向 Back Buffer 中写数据，屏幕从 Frame Buffer 中读数据。VSync 信号负责调度从 Back Buffer 到 Frame Buffer 的复制操作，可认为该复制操作在瞬间完成。其实，该复制操作是等价后的效果，实际上双缓冲的实现方式是交换 Back Buffer 和 Frame Buffer 的名字，更具体的说是交换内存地址。<br>双缓冲的模型下，工作流程这样的：<br>在某个时间点，一个屏幕刷新周期完成，进入短暂的刷新空白期。此时，VSync 信号产生，先完成复制操作，然后通知 CPU/GPU 绘制下一帧图像。复制操作完成后屏幕开始下一个刷新周期，即将刚复制到 Frame Buffer 的数据显示到屏幕上。</p><p>在这种模型下，只有当 VSync 信号产生时，CPU/GPU 才会开始绘制。这样，当帧率大于刷新频率时，帧率就会被迫跟刷新频率保持同步，从而避免“tearing”现象。</p><p>注意，当 VSync 信号发出时，如果 GPU/CPU 正在生产帧数据，此时不会发生复制操作。屏幕进入下一个刷新周期时，从 Frame Buffer 中取出的是“老”数据，而非正在产生的帧数据，即两个刷新周期显示的是同一帧数据。这是我们称发生了“掉帧”（Dropped Frame，Skipped Frame，Jank）现象。<br><img src="/images/double_buffer.jpg" alt=""></p><h2 id="三缓存（Triple-Buffer）"><a href="#三缓存（Triple-Buffer）" class="headerlink" title="三缓存（Triple Buffer）"></a>三缓存（Triple Buffer）</h2><p>双缓冲的问题在于：当 CPU/GPU 绘制一帧的时间超过 16 ms 时，会产生 Jank。更要命的是，产生 Jank 的那一帧的显示期间，GPU/CPU 都是在闲置的。<br>如下图，A、B 和 C 都是 Buffer。蓝色代表 CPU 生成 Display List，绿色代表 GPU 执行 Display List 中的命令从而生成帧，黄色代表生成帧完成。<br><img src="/images/double_buffer_jank.jpg" alt=""><br>如果有第三个 Buffer 能让 CPU/GPU 在这个时候继续工作，那就完全可以避免第二个 Jank 的发生了！<br><img src="/images/triple_buffer_jank.jpg" alt=""><br>于是就有了三缓存<br><img src="/images/triple_buffer.jpg" alt=""></p><p>需要注意的是，第三个缓存并不是总是存在的，只要当需要的时候才会创建。之所以这样，是因为三缓存会显著增加用户输入到显示的延迟时间。如上图，帧 C 是在第 2 个刷新周期产生的，但却是在第 4 个周期显示的。最坏的情况下，你会同时遇到输入延迟和卡顿现象。</p><h1 id="android-windowIsTranslucent的设置对activity-生命周期的影响"><a href="#android-windowIsTranslucent的设置对activity-生命周期的影响" class="headerlink" title="android:windowIsTranslucent的设置对activity 生命周期的影响"></a>android:windowIsTranslucent的设置对activity 生命周期的影响</h1><p>遇到的问题</p><h2 id="主模块AndroidManifest中设置了如下代码"><a href="#主模块AndroidManifest中设置了如下代码" class="headerlink" title="主模块AndroidManifest中设置了如下代码:"></a>主模块AndroidManifest中设置了如下代码:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;application</div><div class="line">        ...</div><div class="line">        tools:replace=&quot;android:allowBackup, android:theme&quot;&gt;</div></pre></td></tr></table></figure><h2 id="主模块style中设置了如下代码"><a href="#主模块style中设置了如下代码" class="headerlink" title="主模块style中设置了如下代码"></a>主模块style中设置了如下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</div></pre></td></tr></table></figure><p>最后导致子模块中所有的theme都被替换掉了，子模块中的activity生命周期都受到了影响，切换时不会调用onStop和onStart这些可见性的回调。<br>通过以下方法查看visible可以判断activity可见性<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys activity activities</div></pre></td></tr></table></figure><p></p><h1 id="如果跟踪actvity-被谁打开被谁关闭"><a href="#如果跟踪actvity-被谁打开被谁关闭" class="headerlink" title="如果跟踪actvity 被谁打开被谁关闭"></a>如果跟踪actvity 被谁打开被谁关闭</h1><h2 id="跟踪打开"><a href="#跟踪打开" class="headerlink" title="跟踪打开"></a>跟踪打开</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 过滤log TAG  ActivityManager</div><div class="line">system_process I/ActivityManager: START u0 &#123;flag=0x8000 cmp=com.xxx/xxx&#125; from uid 10029</div></pre></td></tr></table></figure><h2 id="跟踪关闭"><a href="#跟踪关闭" class="headerlink" title="跟踪关闭"></a>跟踪关闭</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 在activity finish() 方法中打印调用栈信息</div><div class="line">StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</div><div class="line">for(StackTraceElement element : stackTraceElements) &#123;</div><div class="line">    Log.i(&quot;peter&quot;, element.getClassName() + &quot;/&quot; + element.getMethodName() + &quot;\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="android-windowIsFloating也有和android-windowIsTranslucent相同的问题"><a href="#android-windowIsFloating也有和android-windowIsTranslucent相同的问题" class="headerlink" title="android:windowIsFloating也有和android:windowIsTranslucent相同的问题"></a>android:windowIsFloating也有和android:windowIsTranslucent相同的问题</h2><h1 id="MotionEvent-ACTION-CANCEL的发出时机"><a href="#MotionEvent-ACTION-CANCEL的发出时机" class="headerlink" title="MotionEvent.ACTION_CANCEL的发出时机"></a>MotionEvent.ACTION_CANCEL的发出时机</h1><ol><li>当view被父view Intercept拦截后</li><li>当正在控制的view 被remove 掉后</li><li>当正在控制的view 所在的activity 被finish后</li></ol></div><div></div><div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2014/04/29/Android-M/" rel="next" title="Android-M"><i class="fa fa-chevron-left"></i> Android-M</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2015/01/07/设计模式/" rel="prev" title="设计模式">设计模式 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div><div class="ds-thread" data-thread-key="<%- page.path %>" data-title="<%- page.title %>" data-url="<%- page.permalink %>"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="peter"><p class="site-author-name" itemprop="name">peter</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">日志</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/javalive09" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="http://stackoverflow.com/users/4674672/peter-zhang" target="_blank" title="S.O."><i class="fa fa-fw fa-stack-overflow"></i> S.O. </a></span><span class="links-of-author-item"><a href="https://200code.com/sites/" target="_blank" title="在线工具"><i class="fa fa-fw fa-globe"></i> 在线工具</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#view"><span class="nav-number">1.</span> <span class="nav-text">view</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#animation"><span class="nav-number">1.1.</span> <span class="nav-text">animation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#帧动画-frame-anim"><span class="nav-number">1.1.1.</span> <span class="nav-text">帧动画 frame anim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#补间动画-tween-anim"><span class="nav-number">1.1.2.</span> <span class="nav-text">补间动画 tween anim</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#alpha"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">alpha</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rotate"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">rotate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scale"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">scale</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#translate"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">translate</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性动画-property-anim"><span class="nav-number">1.1.3.</span> <span class="nav-text">属性动画 property anim</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#valueAnimator"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">valueAnimator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objectAnimator"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">objectAnimator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#offint-offfloat-offobject-offproperty-propertyvalueHolder-setCurrentPlayTime-long-playTime"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">offint , offfloat, offobject, offproperty , propertyvalueHolder, setCurrentPlayTime(long playTime)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interpolator"><span class="nav-number">1.1.4.</span> <span class="nav-text">interpolator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transformation"><span class="nav-number">1.1.5.</span> <span class="nav-text">Transformation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#帧数"><span class="nav-number">1.1.6.</span> <span class="nav-text">帧数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TypeEvaluator"><span class="nav-number">1.1.7.</span> <span class="nav-text">TypeEvaluator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#view-重绘的时机"><span class="nav-number">1.2.</span> <span class="nav-text">view 重绘的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主动重绘"><span class="nav-number">1.2.1.</span> <span class="nav-text">主动重绘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#被动重绘"><span class="nav-number">1.2.2.</span> <span class="nav-text">被动重绘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#view状态变化"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">view状态变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#view结构变化"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">view结构变化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#view绘制过程"><span class="nav-number">1.3.</span> <span class="nav-text">view绘制过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-measure-确定大小"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.measure 确定大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-layout-确定位置"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.layout 确定位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-draw-绘制"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.draw 绘制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#invalidated调用时机"><span class="nav-number">1.3.4.</span> <span class="nav-text">invalidated调用时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#requestlayout调用时机"><span class="nav-number">1.3.5.</span> <span class="nav-text">requestlayout调用时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-invalidate方法研究"><span class="nav-number">1.4.</span> <span class="nav-text">View invalidate方法研究</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一个非容器类的view-调用Invalidate"><span class="nav-number">1.4.1.</span> <span class="nav-text">一个非容器类的view 调用Invalidate():</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个容器类的view调用Invalidate"><span class="nav-number">1.4.2.</span> <span class="nav-text">一个容器类的view调用Invalidate():</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论"><span class="nav-number">1.4.3.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#addView-源码调用顺序的迷惑"><span class="nav-number">1.5.</span> <span class="nav-text">addView 源码调用顺序的迷惑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#view-的OnTouchListener和OnClickListener的区别"><span class="nav-number">1.6.</span> <span class="nav-text">view 的OnTouchListener和OnClickListener的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OnTouchListener的触发逻辑"><span class="nav-number">1.6.1.</span> <span class="nav-text">OnTouchListener的触发逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OnClickListener的触发逻辑"><span class="nav-number">1.6.2.</span> <span class="nav-text">OnClickListener的触发逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.6.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-touch的传递流程"><span class="nav-number">1.7.</span> <span class="nav-text">View touch的传递流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatchTouchEvent-调用的时机"><span class="nav-number">1.7.1.</span> <span class="nav-text">dispatchTouchEvent()调用的时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#onInterceptTouchEvent-调用时机"><span class="nav-number">1.7.2.</span> <span class="nav-text">onInterceptTouchEvent()调用时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#onTouchEvent-调用时机"><span class="nav-number">1.7.3.</span> <span class="nav-text">onTouchEvent()调用时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-draw方法传递流程"><span class="nav-number">1.8.</span> <span class="nav-text">View draw方法传递流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何叠加多个listview-和gridview"><span class="nav-number">1.9.</span> <span class="nav-text">如何叠加多个listview 和gridview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何获取listview的内容高度"><span class="nav-number">1.10.</span> <span class="nav-text">如何获取listview的内容高度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#android-scrollview-滚动时会调用onlayout么"><span class="nav-number">1.11.</span> <span class="nav-text">android scrollview 滚动时会调用onlayout么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-中的-onAttachedToWindow-onDetachedFromWindow-的作用是什么？"><span class="nav-number">1.12.</span> <span class="nav-text">View 中的 onAttachedToWindow onDetachedFromWindow 的作用是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调用流程"><span class="nav-number">1.12.1.</span> <span class="nav-text">调用流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何在xml中引用内部类？"><span class="nav-number">1.13.</span> <span class="nav-text">如何在xml中引用内部类？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewB继承自View"><span class="nav-number">1.13.1.</span> <span class="nav-text">ViewB继承自View</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewB继承自ViewGroup"><span class="nav-number">1.13.2.</span> <span class="nav-text">ViewB继承自ViewGroup</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#translateAnimation-setFillxxx-作用是什么？"><span class="nav-number">1.14.</span> <span class="nav-text">translateAnimation.setFillxxx()作用是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#translateAnimation-setFillAfter-true"><span class="nav-number">1.14.1.</span> <span class="nav-text">translateAnimation.setFillAfter(true);</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#translateAnimation-setFillBefore-true"><span class="nav-number">1.14.2.</span> <span class="nav-text">translateAnimation.setFillBefore(true);</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义菜单时点击Menu后，自定义菜单显示，但是activity窗口没获得焦点。为什么？"><span class="nav-number">1.15.</span> <span class="nav-text">自定义菜单时点击Menu后，自定义菜单显示，但是activity窗口没获得焦点。为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取View的坐标"><span class="nav-number">1.16.</span> <span class="nav-text">获取View的坐标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取在所在父View中的坐标"><span class="nav-number">1.16.1.</span> <span class="nav-text">获取在所在父View中的坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取在整个屏幕中的坐标"><span class="nav-number">1.16.2.</span> <span class="nav-text">获取在整个屏幕中的坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取在所在Activity的window中的坐标"><span class="nav-number">1.16.3.</span> <span class="nav-text">获取在所在Activity的window中的坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getLocalVisibleRect"><span class="nav-number">1.16.4.</span> <span class="nav-text">getLocalVisibleRect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getGlobalVisibleRect"><span class="nav-number">1.16.5.</span> <span class="nav-text">getGlobalVisibleRect</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#canvas的画文字方法参数的意义？"><span class="nav-number">1.17.</span> <span class="nav-text">canvas的画文字方法参数的意义？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#像素的结构"><span class="nav-number">1.18.</span> <span class="nav-text">像素的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#canvas如何画出缩放的bitmap"><span class="nav-number">1.19.</span> <span class="nav-text">canvas如何画出缩放的bitmap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法1"><span class="nav-number">1.19.1.</span> <span class="nav-text">方法1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法2"><span class="nav-number">1.19.2.</span> <span class="nav-text">方法2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View自定义长按菜单实现"><span class="nav-number">1.20.</span> <span class="nav-text">View自定义长按菜单实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#触发流程"><span class="nav-number">1.20.1.</span> <span class="nav-text">触发流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应逻辑"><span class="nav-number">1.20.2.</span> <span class="nav-text">响应逻辑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算android-view的FPS"><span class="nav-number">1.21.</span> <span class="nav-text">计算android view的FPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何计算："><span class="nav-number">1.21.1.</span> <span class="nav-text">如何计算：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码"><span class="nav-number">1.22.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#android中改变view位置的几种方法"><span class="nav-number">1.23.</span> <span class="nav-text">android中改变view位置的几种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调用-layout方法"><span class="nav-number">1.23.1.</span> <span class="nav-text">调用 layout方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置MarginLayoutParams，-然后调用setLayoutParams"><span class="nav-number">1.23.2.</span> <span class="nav-text">设置MarginLayoutParams， 然后调用setLayoutParams()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外容器scrollTo-方法。改变view窗体位置。会改变所有的子View位置"><span class="nav-number">1.23.3.</span> <span class="nav-text">外容器scrollTo 方法。改变view窗体位置。会改变所有的子View位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#view-的scroll系列方法的理解"><span class="nav-number">1.24.</span> <span class="nav-text">view 的scroll系列方法的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#scrollTo"><span class="nav-number">1.24.1.</span> <span class="nav-text">scrollTo():</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scrollBy"><span class="nav-number">1.24.2.</span> <span class="nav-text">scrollBy()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setScrollX"><span class="nav-number">1.24.3.</span> <span class="nav-text">setScrollX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setScrollY"><span class="nav-number">1.24.4.</span> <span class="nav-text">setScrollY</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LayoutInflater-的inflate-int-resource-ViewGroup-root-boolean-attachToRoot-方法研究"><span class="nav-number">1.25.</span> <span class="nav-text">LayoutInflater 的inflate(int resource, ViewGroup root, boolean attachToRoot)方法研究</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#情况一：-root-null-attachToRoot-false"><span class="nav-number">1.25.1.</span> <span class="nav-text">情况一： root =null, attachToRoot = false;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#情况二：root-null-attachToRoot-false"><span class="nav-number">1.25.2.</span> <span class="nav-text">情况二：root != null, attachToRoot = false;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#情况三：root-null-attachToRoot-true"><span class="nav-number">1.25.3.</span> <span class="nav-text">情况三：root != null, attachToRoot = true;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">1.25.4.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#root为空时"><span class="nav-number">1.25.4.1.</span> <span class="nav-text">root为空时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#root-不为空时"><span class="nav-number">1.25.4.2.</span> <span class="nav-text">root 不为空时</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ViewPager-SimpleOnPageChangeListener中回调函数的调用场景"><span class="nav-number">1.26.</span> <span class="nav-text">ViewPager SimpleOnPageChangeListener中回调函数的调用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-onPageScrolled-int-position-float-positionOffset-int-positionOffsetPixels-："><span class="nav-number">1.26.1.</span> <span class="nav-text">1.onPageScrolled(int position, float positionOffset, int positionOffsetPixels)：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#被调用的场景"><span class="nav-number">1.26.1.1.</span> <span class="nav-text">被调用的场景:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景"><span class="nav-number">1.26.1.2.</span> <span class="nav-text">使用场景:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-onPageSelected-int-position"><span class="nav-number">1.26.2.</span> <span class="nav-text">2.onPageSelected(int position)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#被调用的场景："><span class="nav-number">1.26.2.1.</span> <span class="nav-text">被调用的场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景："><span class="nav-number">1.26.2.2.</span> <span class="nav-text">使用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-onPageScrollStateChanged-int-state"><span class="nav-number">1.26.3.</span> <span class="nav-text">3.onPageScrollStateChanged(int state):</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#被调用的场景：-1"><span class="nav-number">1.26.3.1.</span> <span class="nav-text">被调用的场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景：-1"><span class="nav-number">1.26.3.2.</span> <span class="nav-text">使用场景：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TextView-setEms-方法名字"><span class="nav-number">1.27.</span> <span class="nav-text">TextView setEms 方法名字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View容器-measure-流程"><span class="nav-number">1.28.</span> <span class="nav-text">View容器 measure 流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FrameLayout-onMeasure"><span class="nav-number">1.28.1.</span> <span class="nav-text">FrameLayout onMeasure()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinearLayout-onMeasure"><span class="nav-number">1.28.2.</span> <span class="nav-text">LinearLayout onMeasure()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RelateveLayout-onMeasure"><span class="nav-number">1.28.3.</span> <span class="nav-text">RelateveLayout onMeasure()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbsoluteLayout-onMeasure"><span class="nav-number">1.28.4.</span> <span class="nav-text">AbsoluteLayout onMeasure()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#window"><span class="nav-number">2.</span> <span class="nav-text">window</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#animation-1"><span class="nav-number">2.1.</span> <span class="nav-text">animation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启动动画"><span class="nav-number">2.1.1.</span> <span class="nav-text">启动动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结束动画"><span class="nav-number">2.1.2.</span> <span class="nav-text">结束动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局activity动画"><span class="nav-number">2.1.3.</span> <span class="nav-text">全局activity动画</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不影响系统交互的悬浮窗window参数设置"><span class="nav-number">2.2.</span> <span class="nav-text">不影响系统交互的悬浮窗window参数设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何监听window的back键"><span class="nav-number">2.3.</span> <span class="nav-text">如何监听window的back键</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#修改app-默认动画"><span class="nav-number">3.</span> <span class="nav-text">修改app 默认动画</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设备的适配"><span class="nav-number">4.</span> <span class="nav-text">设备的适配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一套代码适配不同屏幕设备。"><span class="nav-number">4.1.</span> <span class="nav-text">一套代码适配不同屏幕设备。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不透明度列表"><span class="nav-number">5.</span> <span class="nav-text">不透明度列表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#增加view-触摸面积"><span class="nav-number">6.</span> <span class="nav-text">增加view 触摸面积</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设置padding"><span class="nav-number">6.1.</span> <span class="nav-text">设置padding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用TouchDelegate"><span class="nav-number">6.2.</span> <span class="nav-text">使用TouchDelegate</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VSync"><span class="nav-number">7.</span> <span class="nav-text">VSync</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#帧率"><span class="nav-number">7.1.</span> <span class="nav-text">帧率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#屏幕刷新频率"><span class="nav-number">7.2.</span> <span class="nav-text">屏幕刷新频率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VSync-1"><span class="nav-number">7.3.</span> <span class="nav-text">VSync</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单缓存"><span class="nav-number">7.4.</span> <span class="nav-text">单缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双缓存（Double-Buffer）"><span class="nav-number">7.5.</span> <span class="nav-text">双缓存（Double Buffer）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三缓存（Triple-Buffer）"><span class="nav-number">7.6.</span> <span class="nav-text">三缓存（Triple Buffer）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#android-windowIsTranslucent的设置对activity-生命周期的影响"><span class="nav-number">8.</span> <span class="nav-text">android:windowIsTranslucent的设置对activity 生命周期的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#主模块AndroidManifest中设置了如下代码"><span class="nav-number">8.1.</span> <span class="nav-text">主模块AndroidManifest中设置了如下代码:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主模块style中设置了如下代码"><span class="nav-number">8.2.</span> <span class="nav-text">主模块style中设置了如下代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如果跟踪actvity-被谁打开被谁关闭"><span class="nav-number">9.</span> <span class="nav-text">如果跟踪actvity 被谁打开被谁关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#跟踪打开"><span class="nav-number">9.1.</span> <span class="nav-text">跟踪打开</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跟踪关闭"><span class="nav-number">9.2.</span> <span class="nav-text">跟踪关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#android-windowIsFloating也有和android-windowIsTranslucent相同的问题"><span class="nav-number">9.3.</span> <span class="nav-text">android:windowIsFloating也有和android:windowIsTranslucent相同的问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MotionEvent-ACTION-CANCEL的发出时机"><span class="nav-number">10.</span> <span class="nav-text">MotionEvent.ACTION_CANCEL的发出时机</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">peter</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script></body></html>