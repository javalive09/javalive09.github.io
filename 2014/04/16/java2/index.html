<!doctype html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="多线程线程和进程的关系线程寄生在进程中。一个进程中可以有多个线程。进程本质上是一个执行的程序。线程是多任务处理的最小单位。多线程比多进程消耗更少的资源。定义在单个程序中同时执行多个不同的任务。多线程的目的是为了最大限度的利用cpu资源。当程序运行时，会自动产生一个主线程，main方法就在这个主线程中运行。生命周期运行流程控制sleep()睡眠join()加入启动它的线程，让异步变同步yield()"><meta property="og:type" content="article"><meta property="og:title" content="java2"><meta property="og:url" content="http://yoursite.com/2014/04/16/java2/index.html"><meta property="og:site_name" content="200code"><meta property="og:description" content="多线程线程和进程的关系线程寄生在进程中。一个进程中可以有多个线程。进程本质上是一个执行的程序。线程是多任务处理的最小单位。多线程比多进程消耗更少的资源。定义在单个程序中同时执行多个不同的任务。多线程的目的是为了最大限度的利用cpu资源。当程序运行时，会自动产生一个主线程，main方法就在这个主线程中运行。生命周期运行流程控制sleep()睡眠join()加入启动它的线程，让异步变同步yield()"><meta property="og:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/threadlife.jpg"><meta property="og:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/threadlogic.jpg"><meta property="og:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/hashmap.jpg"><meta property="og:updated_time" content="2017-03-15T04:07:17.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java2"><meta name="twitter:description" content="多线程线程和进程的关系线程寄生在进程中。一个进程中可以有多个线程。进程本质上是一个执行的程序。线程是多任务处理的最小单位。多线程比多进程消耗更少的资源。定义在单个程序中同时执行多个不同的任务。多线程的目的是为了最大限度的利用cpu资源。当程序运行时，会自动产生一个主线程，main方法就在这个主线程中运行。生命周期运行流程控制sleep()睡眠join()加入启动它的线程，让异步变同步yield()"><meta name="twitter:image" content="http://7xoxmg.com1.z0.glb.clouddn.com/threadlife.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"always"},fancybox:!1,motion:!1,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2014/04/16/java2/"><title>java2 | 200code</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?afd325d3333e718fc607b569c45d57a4";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">200code</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/04/16/java2/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="peter"><meta itemprop="description" content=""><meta itemprop="image" content="http://7xoxmg.com1.z0.glb.clouddn.com/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="200code"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="200code" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline">java2</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-04-16T21:21:28+08:00">2014-04-16 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a class="cloud-tie-join-count" href="/2014/04/16/java2/#comments" itemprop="discussionUrl"><span class="post-comments-count join-count" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程和进程的关系"><a href="#线程和进程的关系" class="headerlink" title="线程和进程的关系"></a>线程和进程的关系</h2><p>线程寄生在进程中。一个进程中可以有多个线程。<br>进程本质上是一个执行的程序。<br>线程是多任务处理的最小单位。<br>多线程比多进程消耗更少的资源。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在单个程序中同时执行多个不同的任务。多线程的目的是为了最大限度的利用cpu资源。<br>当程序运行时，会自动产生一个主线程，main方法就在这个主线程中运行。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="http://7xoxmg.com1.z0.glb.clouddn.com/threadlife.jpg" alt=""></p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p><img src="http://7xoxmg.com1.z0.glb.clouddn.com/threadlogic.jpg" alt=""></p><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>睡眠</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>加入启动它的线程，让异步变同步</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>让出，让给相同优先级的其他线程执行</p><h3 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h3><p>notify（），通知其他线程使用cpu资源，一般写在线程执行完后。 （必须在synchronized块或方法中）<br>notify（），wait（），synchronized 是一个组合。他们一定是配合使用的，来进行线程间交互。</p><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><p>sleep不释放对象锁（占着cup资源的茅坑不拉屎，睡觉去了）<br>wait 释放对象锁（交出cup资源, monitor锁资源，进入等待池）<br>wait 使用时线程必须有对象锁。（必须在synchronized块或方法中）</p><h3 id="synchronized-的几种使用场景"><a href="#synchronized-的几种使用场景" class="headerlink" title="synchronized 的几种使用场景"></a>synchronized 的几种使用场景</h3><p>对象中的同步方法: 锁是对象本身。<br>静态的同步方法：锁是方法所在的类class对象。</p><h3 id="如何做并发加法"><a href="#如何做并发加法" class="headerlink" title="如何做并发加法"></a>如何做并发加法</h3><h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>AtomicLong<br>AtomicInteger<br>incrementAndGet() decrementAndGet()</p><h4 id="java8-并发加法器"><a href="#java8-并发加法器" class="headerlink" title="java8 并发加法器"></a>java8 并发加法器</h4><p>LongAdder<br>DoubleAdder<br>Android N之后支持java 8</p><hr><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>缓冲流速度快的原因： 不用每次都频繁的和硬件设备（扇区）进行读写。和硬件设备读写最影响速度</p><h2 id="InputStream-read方法"><a href="#InputStream-read方法" class="headerlink" title="InputStream read方法"></a>InputStream read方法</h2><p>提供的两种都是将流读入byte[]中。无参Read（），byte[0] &amp; 0xff 由于我们需要的是2进制内容，而不是补码，所以要进行高位清零，&amp;0xff可以实现清零功能。返回int类型的内容。其内部也是调用有参的read方法，只不过是一个byte，一个byte的读，然后转成int 返回。</p><h2 id="OutputStream-write方法"><a href="#OutputStream-write方法" class="headerlink" title="OutputStream write方法"></a>OutputStream write方法</h2><p>都是将byte[]、int(里面装byte型内容)写入流中。</p><blockquote><p>注：byte[]相当于转移流的小容器，小桶<br>ByteArrayOutputstream（）含有可扩展的byte[]属性。用于装内容。流写入内存中的操作。把流变成数组。Bytearray out<br>ByteArrayInputstream（）把数组变成流。Bytearray in 把内存作为输出方式</p></blockquote><hr><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>容器中只能存放对象</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>对应的工具类Collections，包含排序、洗牌等操作</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>本质是Object数组<br>private transient Object[] elementData<br>默认数组的长度为10<br>add时超过10则数组长度增加原来长度的一半<br>list变数组：（T[]）list.toArray(newT[list.size()]);</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>本质是双向的链表<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private static  class  Node&lt;E&gt;&#123;</div><div class="line"></div><div class="line">        E item;</div><div class="line"></div><div class="line">        Node&lt;E&gt; next;</div><div class="line"></div><div class="line">       Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>add是new Node 节点，然后关联起来。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>和数学上的集合的概念相同，元素不重复</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>本质是HashMap，无序的set<br>private transient HashMap<e ,="" object="">map ;<br>add时用key来存值，value为一个object对象<br>可以用来做随机抽奖的容器。</e></p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>本质是 TreeMap，有序的set<br>构造时可以加入comparator 参数，自定义定义排序规则<br>add时用key来存值，value为一个object对象</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>key无序的map，本质是Entry数组和单向链表的结合。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">transient Entry[] table</div><div class="line">static Entry &lt;K,V&gt; implementsMap.Entry&lt;K,V&gt;&#123;</div><div class="line"></div><div class="line">       final K key;</div><div class="line"></div><div class="line">       V value;</div><div class="line"></div><div class="line">       Entry&lt;K,V&gt; next;</div><div class="line"></div><div class="line">       Final int hash;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>默认数组长度为16<br>增加容量时2倍增加<br>put元素时，会先对比hash值和equals内容。判断键值是否相等。<br>可以用来做统计文字出现次数的容器<br><img src="http://7xoxmg.com1.z0.glb.clouddn.com/hashmap.jpg" alt=""></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>key 有序的map</p><h2 id="为什么重写类中的equals方法必须重写hashcode"><a href="#为什么重写类中的equals方法必须重写hashcode" class="headerlink" title="为什么重写类中的equals方法必须重写hashcode"></a>为什么重写类中的equals方法必须重写hashcode</h2><p>将对象放到集合（set、map）时会涉及对比hashcode的情况。如果不重写调用的hashcode方法则会调用object类的hashcode方法（对象的地址），这样会造成内容相同的对象，在内存地址不同的情况下，会被存入set、map中。但是集合中要求对象中的内容不能重复的。这样就矛盾了</p><hr><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="静态内部类（Static-Inner-Class）"><a href="#静态内部类（Static-Inner-Class）" class="headerlink" title="静态内部类（Static Inner Class）"></a>静态内部类（Static Inner Class）</h2><p>static 修饰的内部类<br>只能访问外部类的静态成员变量与静态方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Outerclass.InnerClass inner = newOuterClass.InnerClass();</div></pre></td></tr></table></figure><p></p><p>静态内部类和非静态内部类的唯一区别是：<br>静态内部类没有了指向外部类的引用<br>如果内部类不会引用到外部类的东西的话，强烈建议使用静态内部类，因为这样更节省资源，减少内部类指向外部类的引用——Effective Java</p><h2 id="成员内部类（Member-Inner-Class）"><a href="#成员内部类（Member-Inner-Class）" class="headerlink" title="成员内部类（Member Inner Class）"></a>成员内部类（Member Inner Class）</h2><p>和成员同一级别的内部类</p><p>可以访问外部类的所有成员（成员变量、方法）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OuterClass.InnerClass inner = new OuterClass().newInnerClass();</div></pre></td></tr></table></figure><p></p><p>可以加括号理解(new OutClass()).newInnerClass();</p><h2 id="局部内部类（Local-Inner-Class）"><a href="#局部内部类（Local-Inner-Class）" class="headerlink" title="局部内部类（Local Inner Class）"></a>局部内部类（Local Inner Class）</h2><p>方法中的内部类<br>访问外部类成员变量的方式：OuterClass.this.a;<br>只能访问所在方法中的final变量</p><h2 id="匿名内部类（Anonymous-Inner-Class）"><a href="#匿名内部类（Anonymous-Inner-Class）" class="headerlink" title="匿名内部类（Anonymous Inner Class）"></a>匿名内部类（Anonymous Inner Class）</h2><p>隐式的继承一个父类或实现一个借口<br>自动向上转型</p><h2 id="引入内部类要解决的问题是"><a href="#引入内部类要解决的问题是" class="headerlink" title="引入内部类要解决的问题是"></a>引入内部类要解决的问题是</h2><p>一个类可以访问另一个类的私有成员（封装性）<br>让Java可以实现多继承</p></div><div></div><div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2014/04/16/java1/" rel="next" title="java1"><i class="fa fa-chevron-left"></i> java1</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2014/04/16/java3/" rel="prev" title="java3">java3 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div></div><div class="ds-thread" data-thread-key="<%- page.path %>" data-title="<%- page.title %>" data-url="<%- page.permalink %>"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://7xoxmg.com1.z0.glb.clouddn.com/avatar.jpg" alt="peter"><p class="site-author-name" itemprop="name">peter</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">日志</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/javalive09" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="http://stackoverflow.com/users/4674672/peter-zhang" target="_blank" title="Stack Overflow"><i class="fa fa-fw fa-stack-overflow"></i> Stack Overflow </a></span><span class="links-of-author-item"><a href="/about" target="_blank" title="工具网站"><i class="fa fa-fw fa-globe"></i> 工具网站</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程"><span class="nav-number">1.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程和进程的关系"><span class="nav-number">1.1.</span> <span class="nav-text">线程和进程的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义"><span class="nav-number">1.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生命周期"><span class="nav-number">1.3.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行流程"><span class="nav-number">1.4.</span> <span class="nav-text">运行流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制"><span class="nav-number">1.5.</span> <span class="nav-text">控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep"><span class="nav-number">1.5.1.</span> <span class="nav-text">sleep()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join"><span class="nav-number">1.5.2.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield"><span class="nav-number">1.5.3.</span> <span class="nav-text">yield()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#notify"><span class="nav-number">1.5.4.</span> <span class="nav-text">notify()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep和wait的区别"><span class="nav-number">1.5.5.</span> <span class="nav-text">sleep和wait的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-的几种使用场景"><span class="nav-number">1.5.6.</span> <span class="nav-text">synchronized 的几种使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何做并发加法"><span class="nav-number">1.5.7.</span> <span class="nav-text">如何做并发加法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#atomic"><span class="nav-number">1.5.7.1.</span> <span class="nav-text">atomic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java8-并发加法器"><span class="nav-number">1.5.7.2.</span> <span class="nav-text">java8 并发加法器</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO流"><span class="nav-number">2.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InputStream-read方法"><span class="nav-number">2.1.</span> <span class="nav-text">InputStream read方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OutputStream-write方法"><span class="nav-number">2.2.</span> <span class="nav-text">OutputStream write方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#容器"><span class="nav-number">3.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection"><span class="nav-number">3.1.</span> <span class="nav-text">Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">3.1.1.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">LinkedList</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">3.1.2.</span> <span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">TreeSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">3.2.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">3.2.1.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-number">3.2.2.</span> <span class="nav-text">TreeMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么重写类中的equals方法必须重写hashcode"><span class="nav-number">3.3.</span> <span class="nav-text">为什么重写类中的equals方法必须重写hashcode</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内部类"><span class="nav-number">4.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#静态内部类（Static-Inner-Class）"><span class="nav-number">4.1.</span> <span class="nav-text">静态内部类（Static Inner Class）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员内部类（Member-Inner-Class）"><span class="nav-number">4.2.</span> <span class="nav-text">成员内部类（Member Inner Class）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部内部类（Local-Inner-Class）"><span class="nav-number">4.3.</span> <span class="nav-text">局部内部类（Local Inner Class）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名内部类（Anonymous-Inner-Class）"><span class="nav-number">4.4.</span> <span class="nav-text">匿名内部类（Anonymous Inner Class）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引入内部类要解决的问题是"><span class="nav-number">4.5.</span> <span class="nav-text">引入内部类要解决的问题是</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">peter</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script>var cloudTieConfig={url:document.location.href,sourceId:"",productKey:"a44a85017991439782ca46cd64b41841",target:"cloud-tie-wrapper"}</script><script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script></body></html>